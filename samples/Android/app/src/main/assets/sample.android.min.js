/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 260);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function PointMake(x, y) {
    return { x: x, y: y };
}
exports.PointMake = PointMake;
function PointEqual(point1, point2) {
    return point1.x === point2.x && point1.y === point2.y;
}
exports.PointEqual = PointEqual;
exports.PointZero = PointMake(0, 0);
function SizeMake(width, height) {
    return { width: width, height: height };
}
exports.SizeMake = SizeMake;
function SizeEqual(size1, size2) {
    return size1.width === size2.width && size1.height === size2.height;
}
exports.SizeEqual = SizeEqual;
exports.SizeZero = SizeMake(0, 0);
function RectMake(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}
exports.RectMake = RectMake;
exports.RectZero = RectMake(0, 0, 0, 0);
function RectEqual(rect1, rect2) {
    return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
}
exports.RectEqual = RectEqual;
function RectInside(rect1, rect2) {
    return rect2.x > rect1.x && rect2.x + rect2.width < rect1.x + rect1.width && rect2.y > rect1.y && rect2.y + rect2.height < rect1.y + rect1.height;
}
exports.RectInside = RectInside;
function InsetsMake(top, left, bottom, right) {
    return { top: top, left: left, bottom: bottom, right: right };
}
exports.InsetsMake = InsetsMake;


/***/ }),

/***/ 121:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="xtr.d.ts" />
var View_1 = __webpack_require__(9);
var ImageView_1 = __webpack_require__(62);
var Label_1 = __webpack_require__(122);
var Rect_1 = __webpack_require__(0);
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        _this.imageView = new ImageView_1.ImageView();
        _this.titleLabel = new Label_1.Label();
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRButton.createScriptObject(rect || Rect_1.RectZero, _this);
            _this.addSubview(_this.imageView);
            _this.addSubview(_this.titleLabel);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(Button.prototype, "title", {
        get: function () {
            return this.nativeObject.xtr_title();
        },
        set: function (value) {
            this.nativeObject.xtr_setTitle(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "font", {
        get: function () {
            return this.nativeObject.xtr_font();
        },
        set: function (value) {
            this.nativeObject.xtr_setFont(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "image", {
        get: function () {
            return this.nativeObject.xtr_image();
        },
        set: function (value) {
            this.nativeObject.xtr_setImage(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "color", {
        get: function () {
            return this.nativeObject.xtr_color();
        },
        set: function (value) {
            this.nativeObject.xtr_setColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "vertical", {
        get: function () {
            return this.nativeObject.xtr_vertical();
        },
        set: function (value) {
            this.nativeObject.xtr_setVertical(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "inset", {
        get: function () {
            return this.nativeObject.xtr_inset();
        },
        set: function (value) {
            this.nativeObject.xtr_setInset(value);
        },
        enumerable: true,
        configurable: true
    });
    Button.prototype.willMoveToSuperview = function (newSuperview) {
        _super.prototype.willMoveToSuperview.call(this, newSuperview);
        if (newSuperview) {
            this.color = newSuperview.tintColor;
        }
    };
    Button.prototype.handleTouchUpInside = function () {
        this.onTouchUpInside && this.onTouchUpInside();
    };
    Button.prototype.handleHighlighted = function (highligted) {
        this.onHighlighted && this.onHighlighted(highligted);
    };
    return Button;
}(View_1.View));
exports.Button = Button;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRButton$InnerObject") === 0) {
        return new Label_1.Label(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 122:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/// <reference path="xtr.d.ts" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var TextAlignment;
(function (TextAlignment) {
    TextAlignment[TextAlignment["Left"] = 0] = "Left";
    TextAlignment[TextAlignment["Center"] = 1] = "Center";
    TextAlignment[TextAlignment["Right"] = 2] = "Right";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var TextVerticalAlignment;
(function (TextVerticalAlignment) {
    TextVerticalAlignment[TextVerticalAlignment["Top"] = 0] = "Top";
    TextVerticalAlignment[TextVerticalAlignment["Center"] = 1] = "Center";
    TextVerticalAlignment[TextVerticalAlignment["Bottom"] = 2] = "Bottom";
})(TextVerticalAlignment = exports.TextVerticalAlignment || (exports.TextVerticalAlignment = {}));
var LineBreakMode;
(function (LineBreakMode) {
    LineBreakMode[LineBreakMode["WordWrapping"] = 0] = "WordWrapping";
    LineBreakMode[LineBreakMode["TruncatingTail"] = 4] = "TruncatingTail";
})(LineBreakMode = exports.LineBreakMode || (exports.LineBreakMode = {}));
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRLabel.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(Label.prototype, "text", {
        get: function () {
            return this.nativeObject.xtr_text();
        },
        set: function (value) {
            this.nativeObject.xtr_setText(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "font", {
        get: function () {
            return this.nativeObject.xtr_font();
        },
        set: function (value) {
            this.nativeObject.xtr_setFont(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textColor", {
        get: function () {
            return this.nativeObject.xtr_textColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textAlignment", {
        get: function () {
            return this.nativeObject.xtr_textAlignment();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextAlignment(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "numberOfLines", {
        get: function () {
            return this.nativeObject.xtr_numberOfLines();
        },
        set: function (value) {
            this.nativeObject.xtr_setNumberOfLines(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "lineBreakMode", {
        get: function () {
            return this.nativeObject.xtr_lineBreakMode();
        },
        set: function (value) {
            this.nativeObject.xtr_setLineBreakMode(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "lineSpace", {
        get: function () {
            return this.nativeObject.xtr_lineSpace();
        },
        set: function (value) {
            this.nativeObject.xtr_setLineSpace(value);
        },
        enumerable: true,
        configurable: true
    });
    Label.prototype.textRectForBounds = function (bounds) {
        return this.nativeObject.xtr_textRectForBounds(bounds);
    };
    return Label;
}(View_1.View));
exports.Label = Label;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRLabel$InnerObject") === 0) {
        return new Label(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 123:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var Color_1 = __webpack_require__(6);
var Scroller = __webpack_require__(58);
var ScrollView = /** @class */ (function (_super) {
    __extends(ScrollView, _super);
    function ScrollView(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        _this._contentSize = Rect_1.SizeZero;
        _this._isScrollEnabled = true;
        _this._bounces = true;
        _this._isDirectionalLockEnabled = true;
        _this._showsHorizontalScrollIndicator = true;
        _this._showsVerticalScrollIndicator = true;
        _this._alwaysBounceVertical = false;
        _this._alwaysBounceHorizontal = false;
        // Indicators
        _this._tracking = false;
        _this._indicatorHidingTimer = 0;
        _this._restoreInteractiveChildrenTimer = 0;
        _this._indicatorShowed = false;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.innerView = new View_1.View();
            _this.nativeObject = XTRScrollView.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.horizonalScrollIndicator = new View_1.View();
            _this.horizonalScrollIndicator.backgroundColor = new Color_1.Color(0x8f / 0xff, 0x8f / 0xff, 0x90 / 0xff);
            _this.horizonalScrollIndicator.cornerRadius = 1.0;
            _this.horizonalScrollIndicator.alpha = 0.0;
            _super.prototype.addSubview.call(_this, _this.horizonalScrollIndicator);
            _this.verticalScrollIndicator = new View_1.View();
            _this.verticalScrollIndicator.backgroundColor = new Color_1.Color(0x8f / 0xff, 0x8f / 0xff, 0x90 / 0xff);
            _this.verticalScrollIndicator.cornerRadius = 1.0;
            _this.verticalScrollIndicator.alpha = 0.0;
            _super.prototype.addSubview.call(_this, _this.verticalScrollIndicator);
            _this.resetScroller();
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(ScrollView.prototype, "contentSize", {
        get: function () {
            return this._contentSize;
        },
        set: function (value) {
            this._contentSize = value;
            this.nativeObject.xtr_setContentSize(value);
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "contentOffset", {
        get: function () {
            return this.nativeObject.xtr_contentOffset();
        },
        set: function (value) {
            this.nativeObject.xtr_setContentOffset(value);
            this.resetIndicator();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "isScrollEnabled", {
        get: function () {
            return this._isScrollEnabled;
        },
        set: function (value) {
            this._isScrollEnabled = value;
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "bounces", {
        get: function () {
            return this._bounces;
        },
        set: function (value) {
            this._bounces = value;
            this.nativeObject.xtr_setBounce(value);
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "isDirectionalLockEnabled", {
        get: function () {
            return this._isDirectionalLockEnabled;
        },
        set: function (value) {
            this._isDirectionalLockEnabled = value;
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "showsHorizontalScrollIndicator", {
        get: function () {
            return this._showsHorizontalScrollIndicator;
        },
        set: function (value) {
            this._showsHorizontalScrollIndicator = value;
            this.horizonalScrollIndicator.hidden = !value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "showsVerticalScrollIndicator", {
        get: function () {
            return this._showsVerticalScrollIndicator;
        },
        set: function (value) {
            this._showsVerticalScrollIndicator = value;
            this.verticalScrollIndicator.hidden = !value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "alwaysBounceVertical", {
        get: function () {
            return this._alwaysBounceVertical;
        },
        set: function (value) {
            this._alwaysBounceVertical = value;
            this.nativeObject.xtr_setAlwaysBounceVertical(value);
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollView.prototype, "alwaysBounceHorizontal", {
        get: function () {
            return this._alwaysBounceHorizontal;
        },
        set: function (value) {
            this._alwaysBounceHorizontal = value;
            this.nativeObject.xtr_setAlwaysBounceHorizontal(value);
            this.resetScroller();
        },
        enumerable: true,
        configurable: true
    });
    ScrollView.prototype.layoutSubviews = function () {
        _super.prototype.layoutSubviews.call(this);
        this.innerView.frame = this.bounds;
        this.resetScroller();
    };
    // Touches
    ScrollView.prototype.handleTouchStart = function (touches, timestamp) {
        this._indicatorShowed = false;
        clearTimeout(this._indicatorHidingTimer);
        this._tracking = true;
        var tTouches = [];
        for (var index = 0; index < touches.length; index++) {
            var element = touches[index];
            tTouches.push({ pageX: element.x, pageY: element.y });
        }
        this.scroller.doTouchStart(tTouches, timestamp);
    };
    ScrollView.prototype.handleTouchMove = function (touches, timestamp, childInteracting) {
        var _this = this;
        if (childInteracting === void 0) { childInteracting = false; }
        var tTouches = [];
        for (var index = 0; index < touches.length; index++) {
            var element = touches[index];
            tTouches.push({ pageX: element.x, pageY: element.y });
        }
        this.scroller.doTouchMove(tTouches, timestamp);
        if (!childInteracting) {
            this.nativeObject.xtr_disableChildrenInteractive(true);
        }
        if (!this._indicatorShowed) {
            this._indicatorShowed = true;
            View_1.View.animationWithDuration(0.15, function () {
                _this.verticalScrollIndicator.alpha = 1.0;
                _this.horizonalScrollIndicator.alpha = 1.0;
            });
        }
    };
    ScrollView.prototype.handleTouchEnd = function (touches, timestamp) {
        this._tracking = false;
        this.nativeObject.xtr_markAsDecelarating(true);
        clearTimeout(this._indicatorHidingTimer);
        this._indicatorHidingTimer = setTimeout(this.hideIndicator.bind(this), 250);
        this.scroller.doTouchEnd(timestamp);
    };
    ScrollView.prototype.handleTouchCancel = function () {
        this._tracking = false;
        clearTimeout(this._indicatorHidingTimer);
        this._indicatorHidingTimer = setTimeout(this.hideIndicator.bind(this), 250);
    };
    ScrollView.prototype.resetScroller = function () {
        if (this.scroller === undefined) {
            this.scroller = new Scroller(this.handleScroll.bind(this));
        }
        this.scroller.options.scrollingX = this.isScrollEnabled && (this.contentSize.width > this.bounds.width || this.alwaysBounceHorizontal);
        this.scroller.options.scrollingY = this.isScrollEnabled && (this.contentSize.height > this.bounds.height || this.alwaysBounceVertical);
        this.scroller.options.bouncing = this.bounces;
        this.scroller.options.locking = this.isDirectionalLockEnabled;
        // this.scroller.options.penetrationDeceleration = 0.06
        // this.scroller.options.penetrationAcceleration = 0.06
        this.scroller.setDimensions(this.bounds.width, this.bounds.height, this.contentSize.width, this.contentSize.height);
    };
    ScrollView.prototype.handleScroll = function (x, y) {
        var _this = this;
        this.contentOffset = { x: x, y: y };
        this.onScroll && this.onScroll(this);
        clearTimeout(this._indicatorHidingTimer);
        this._indicatorHidingTimer = setTimeout(this.hideIndicator.bind(this), 250);
        clearTimeout(this._restoreInteractiveChildrenTimer);
        this._restoreInteractiveChildrenTimer = setTimeout(function () { _this.nativeObject.xtr_disableChildrenInteractive(false); _this.nativeObject.xtr_markAsDecelarating(false); }, 150);
    };
    ScrollView.prototype.resetIndicator = function () {
        if (this.contentSize.height > this.bounds.height) {
            var yProgress = this.contentOffset.y / (this.contentSize.height - this.bounds.height);
            var yHeight = this.bounds.height / (this.contentSize.height / this.bounds.height);
            this.verticalScrollIndicator.frame = { x: this.bounds.width - 4, y: yProgress * (this.bounds.height - yHeight), width: 2, height: yHeight };
        }
        else {
            this.verticalScrollIndicator.frame = { x: this.bounds.width - 4, y: 0, width: 2, height: 0 };
        }
        if (this.contentSize.width > this.bounds.width) {
            var xProgress = this.contentOffset.x / (this.contentSize.width - this.bounds.width);
            var xWidth = this.bounds.width / (this.contentSize.width / this.bounds.width);
            this.horizonalScrollIndicator.frame = { x: xProgress * (this.bounds.width - xWidth), y: this.bounds.height - 4, width: xWidth, height: 2 };
        }
        else {
            this.horizonalScrollIndicator.frame = { x: 0, y: this.bounds.height - 4, width: 0, height: 2 };
        }
    };
    ScrollView.prototype.hideIndicator = function () {
        var _this = this;
        if (this._tracking) {
            return;
        }
        View_1.View.animationWithDuration(0.15, function () {
            _this.verticalScrollIndicator.alpha = 0.0;
            _this.horizonalScrollIndicator.alpha = 0.0;
        });
    };
    // Proxy method call to innerView
    ScrollView.prototype.insertSubviewAtIndex = function (subview, atIndex) {
        this.innerView.insertSubviewAtIndex(subview, atIndex);
    };
    ScrollView.prototype.exchangeSubviewAtIndex = function (index1, index2) {
        this.innerView.exchangeSubviewAtIndex(index1, index2);
    };
    ScrollView.prototype.addSubview = function (subview) {
        this.innerView.addSubview(subview);
    };
    ScrollView.prototype.insertSubviewBelow = function (subview, siblingSubview) {
        this.innerView.insertSubviewBelow(subview, siblingSubview);
    };
    ScrollView.prototype.insertSubviewAbove = function (subview, siblingSubview) {
        this.innerView.insertSubviewAbove(subview, siblingSubview);
    };
    ScrollView.prototype.bringSubviewToFront = function (subview) {
        this.innerView.bringSubviewToFront(subview);
    };
    ScrollView.prototype.sendSubviewToBack = function (subview) {
        this.innerView.sendSubviewToBack(subview);
    };
    Object.defineProperty(ScrollView.prototype, "constraints", {
        get: function () {
            return this.innerView.constraints;
        },
        enumerable: true,
        configurable: true
    });
    ScrollView.prototype.addConstraint = function (constraint) {
        this.innerView.addConstraint(constraint);
    };
    ScrollView.prototype.addConstraints = function (constraints) {
        this.innerView.addConstraints(constraints);
    };
    ScrollView.prototype.removeConstraint = function (constraint) {
        this.innerView.removeConstraint(constraint);
    };
    ScrollView.prototype.removeAllConstraints = function () {
        this.innerView.removeAllConstraints();
    };
    return ScrollView;
}(View_1.View));
exports.ScrollView = ScrollView;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRScrollView$InnerObject") === 0) {
        return new ScrollView(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 124:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="xtr.d.ts" />
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var Color_1 = __webpack_require__(6);
var Device_1 = __webpack_require__(19);
var Device_2 = __webpack_require__(125);
var TransformMatrix_1 = __webpack_require__(16);
var ViewController = /** @class */ (function () {
    function ViewController(nativeObject, isChild) {
        if (isChild === void 0) { isChild = false; }
        this.supportOrientations = [Device_1.DeviceOrientation.Portrait];
        if (isChild) {
            return;
        }
        if (nativeObject) {
            this.nativeObject = nativeObject;
            window.XTRObjCreater.store(this);
        }
        else {
            this.nativeObject = XTRViewController.createScriptObject(this);
            window.XTRObjCreater.store(this);
            this.loadView();
        }
    }
    Object.defineProperty(ViewController.prototype, "objectUUID", {
        get: function () {
            return "" + this.nativeObject.objectUUID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewController.prototype, "view", {
        get: function () {
            return this.nativeObject.xtr_view();
        },
        set: function (value) {
            this.nativeObject.xtr_setView(value);
            this.viewRef = value;
        },
        enumerable: true,
        configurable: true
    });
    ViewController.prototype.loadView = function () {
        var view = new View_1.View();
        view.backgroundColor = Color_1.Color.yellowColor;
        view.userInteractionEnabled = true;
        this.view = view;
    };
    ViewController.prototype.viewDidLoad = function () { };
    ViewController.prototype.viewWillAppear = function () { this.childViewControllers.map(function (v) { return v.viewWillAppear(); }); };
    ViewController.prototype.viewDidAppear = function () { this.childViewControllers.map(function (v) { return v.viewDidAppear(); }); };
    ViewController.prototype.viewWillDisappear = function () { this.childViewControllers.map(function (v) { return v.viewWillDisappear(); }); };
    ViewController.prototype.viewDidDisappear = function () { this.childViewControllers.map(function (v) { return v.viewDidDisappear(); }); };
    ViewController.prototype.viewWillLayoutSubviews = function () { };
    ViewController.prototype.viewDidLayoutSubviews = function () { };
    Object.defineProperty(ViewController.prototype, "parentViewController", {
        get: function () {
            return this.nativeObject.xtr_parentViewController();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewController.prototype, "childViewControllers", {
        get: function () {
            var value = this.nativeObject.xtr_childViewControllers();
            var arr = [];
            for (var index = 0; index < value.length; index++) {
                arr.push(value[index]);
            }
            return arr;
        },
        enumerable: true,
        configurable: true
    });
    ViewController.prototype.addChildViewController = function (childController) {
        this.nativeObject.xtr_addChildViewController(childController);
    };
    ViewController.prototype.removeFromParentViewController = function () {
        this.nativeObject.xtr_removeFromParentViewController();
    };
    ViewController.prototype.willMoveToParentViewController = function (parent) { };
    ViewController.prototype.didMoveToParentViewController = function (parent) { };
    Object.defineProperty(ViewController.prototype, "navigationController", {
        get: function () {
            return this.nativeObject.xtr_navigationController();
        },
        enumerable: true,
        configurable: true
    });
    ViewController.prototype.keyboardWillShow = function (frame, duration) {
        this.childViewControllers.slice().forEach(function (t) { return t.keyboardWillShow(frame, duration); });
    };
    ViewController.prototype.keyboardWillHide = function (duration) {
        this.childViewControllers.slice().forEach(function (t) { return t.keyboardWillHide(duration); });
    };
    ViewController.prototype.orientationDidChange = function (sender) {
        var _this = this;
        this.childViewControllers.slice().forEach(function (t) { return t.orientationDidChange(sender); });
        if (this.supportOrientations.indexOf(Device_2.Device.current.orientation) >= 0) {
            if (this.parentViewController && this.parentViewController.className === "NavigationController") {
                if (Device_2.Device.current.orientation === Device_1.DeviceOrientation.Portrait) {
                    sender.handleStatusBarHidden && sender.handleStatusBarHidden(false);
                    setTimeout(function () {
                        if (!_this.parentViewController) {
                            return;
                        }
                        var superViewFrame = _this.parentViewController.view.frame;
                        View_1.View.animationWithBouncinessAndSpeed(1.0, 8.0, function () {
                            _this.view.frame = Rect_1.RectMake(0, 0, superViewFrame.width, superViewFrame.height);
                            _this.view.transform = new TransformMatrix_1.TransformMatrix();
                        });
                    }, 500);
                }
                else if (Device_2.Device.current.orientation === Device_1.DeviceOrientation.LandscapeLeft) {
                    sender.handleStatusBarHidden && sender.handleStatusBarHidden(true);
                    setTimeout(function () {
                        if (!_this.parentViewController) {
                            return;
                        }
                        var superViewFrame = _this.parentViewController.view.frame;
                        View_1.View.animationWithBouncinessAndSpeed(1.0, 8.0, function () {
                            _this.view.frame = Rect_1.RectMake((superViewFrame.width - superViewFrame.height) / 2.0, (superViewFrame.height - superViewFrame.width) / 2.0, superViewFrame.height, superViewFrame.width);
                            _this.view.transform = TransformMatrix_1.TransformMatrix.postRotate(new TransformMatrix_1.TransformMatrix(), -90 * Math.PI / 180);
                        });
                    }, 500);
                }
                else if (Device_2.Device.current.orientation === Device_1.DeviceOrientation.LandscapeRight) {
                    sender.handleStatusBarHidden && sender.handleStatusBarHidden(true);
                    setTimeout(function () {
                        if (!_this.parentViewController) {
                            return;
                        }
                        var superViewFrame = _this.parentViewController.view.frame;
                        View_1.View.animationWithBouncinessAndSpeed(1.0, 8.0, function () {
                            _this.view.frame = Rect_1.RectMake((superViewFrame.width - superViewFrame.height) / 2.0, (superViewFrame.height - superViewFrame.width) / 2.0, superViewFrame.height, superViewFrame.width);
                            _this.view.transform = TransformMatrix_1.TransformMatrix.postRotate(new TransformMatrix_1.TransformMatrix(), 90 * Math.PI / 180);
                        });
                    }, 500);
                }
            }
        }
    };
    return ViewController;
}());
exports.ViewController = ViewController;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (target) {
    if (target.toString().indexOf("com.opensource.xtruntime.XTRViewController$InnerObject") === 0) {
        return new ViewController(target);
    }
    return undefined;
});


/***/ }),

/***/ 125:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Device = /** @class */ (function () {
    function Device(nativeObject) {
        this.nativeObject = nativeObject;
    }
    Object.defineProperty(Device, "current", {
        get: function () {
            return new Device(XTRDevice.xtr_current());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "name", {
        get: function () {
            return this.nativeObject.xtr_name();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "systemName", {
        get: function () {
            return this.nativeObject.xtr_systemName();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "systemVersion", {
        get: function () {
            return this.nativeObject.xtr_systemVersion();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "xtRuntimeVersion", {
        get: function () {
            return this.nativeObject.xtr_xtRuntimeVersion();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "model", {
        get: function () {
            return this.nativeObject.xtr_model();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Device.prototype, "orientation", {
        get: function () {
            return this.nativeObject.xtr_orientation();
        },
        enumerable: true,
        configurable: true
    });
    Device.prototype.isiOS = function () { return false; };
    Device.prototype.isAndroid = function () { return true; };
    Device.prototype.isWeb = function () { return false; };
    return Device;
}());
exports.Device = Device;


/***/ }),

/***/ 14:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(4);
var Color_1 = __webpack_require__(6);
var Rect_1 = __webpack_require__(0);
var TextAlignment;
(function (TextAlignment) {
    TextAlignment[TextAlignment["Left"] = 0] = "Left";
    TextAlignment[TextAlignment["Center"] = 1] = "Center";
    TextAlignment[TextAlignment["Right"] = 2] = "Right";
})(TextAlignment = exports.TextAlignment || (exports.TextAlignment = {}));
var TextVerticalAlignment;
(function (TextVerticalAlignment) {
    TextVerticalAlignment[TextVerticalAlignment["Top"] = 0] = "Top";
    TextVerticalAlignment[TextVerticalAlignment["Center"] = 1] = "Center";
    TextVerticalAlignment[TextVerticalAlignment["Bottom"] = 2] = "Bottom";
})(TextVerticalAlignment = exports.TextVerticalAlignment || (exports.TextVerticalAlignment = {}));
var LineBreakMode;
(function (LineBreakMode) {
    LineBreakMode[LineBreakMode["WordWrapping"] = 0] = "WordWrapping";
    LineBreakMode[LineBreakMode["TruncatingTail"] = 4] = "TruncatingTail";
})(LineBreakMode = exports.LineBreakMode || (exports.LineBreakMode = {}));
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.textColor = new Color_1.Color(0, 0, 0);
        _this.textAlignment = TextAlignment.Left;
        _this.numberOfLines = 1;
        _this.lineBreakMode = LineBreakMode.WordWrapping;
        _this.lineSpace = 12;
        return _this;
    }
    Label.prototype.textRectForBounds = function (bounds) { return Rect_1.RectZero; };
    return Label;
}(View_1.View));
exports.Label = Label;


/***/ }),

/***/ 15:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Screen = /** @class */ (function () {
    function Screen(width, height, scale) {
        this.width = width;
        this.height = height;
        this.scale = scale;
    }
    Screen.prototype.bounds = function () {
        return { x: 0, y: 0, width: this.width, height: this.height };
    };
    Screen.withScale = function (value) {
        return value * Screen.mainScreen().scale;
    };
    Screen.outScale = function (value) {
        return value / Screen.mainScreen().scale;
    };
    Screen.mainScreen = function () { return new Screen(0, 0, 1); };
    return Screen;
}());
exports.Screen = Screen;


/***/ }),

/***/ 16:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var TransformMatrixAlgorithm = /** @class */ (function () {
    function TransformMatrixAlgorithm() {
        this.props = [];
        this.props[0] = 1;
        this.props[1] = 0;
        this.props[2] = 0;
        this.props[3] = 0;
        this.props[4] = 0;
        this.props[5] = 1;
        this.props[6] = 0;
        this.props[7] = 0;
        this.props[8] = 0;
        this.props[9] = 0;
        this.props[10] = 1;
        this.props[11] = 0;
        this.props[12] = 0;
        this.props[13] = 0;
        this.props[14] = 0;
        this.props[15] = 1;
    }
    TransformMatrixAlgorithm.prototype.rotate = function (angle) {
        if (angle === 0) {
            return this;
        }
        var mCos = Math.cos(angle);
        var mSin = Math.sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    TransformMatrixAlgorithm.prototype.rotateX = function (angle) {
        if (angle === 0) {
            return this;
        }
        var mCos = Math.cos(angle);
        var mSin = Math.sin(angle);
        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
    };
    TransformMatrixAlgorithm.prototype.rotateY = function (angle) {
        if (angle === 0) {
            return this;
        }
        var mCos = Math.cos(angle);
        var mSin = Math.sin(angle);
        return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
    };
    TransformMatrixAlgorithm.prototype.rotateZ = function (angle) {
        if (angle === 0) {
            return this;
        }
        var mCos = Math.cos(angle);
        var mSin = Math.sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    TransformMatrixAlgorithm.prototype.shear = function (sx, sy) {
        return this._t(1, sy, sx, 1, 0, 0);
    };
    TransformMatrixAlgorithm.prototype.skew = function (ax, ay) {
        return this.shear(Math.tan(ax), Math.tan(ay));
    };
    TransformMatrixAlgorithm.prototype.skewFromAxis = function (ax, angle) {
        var mCos = Math.cos(angle);
        var mSin = Math.sin(angle);
        return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        this._t(1, 0, 0, 0, Math.tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, Math.tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
    };
    TransformMatrixAlgorithm.prototype.scale = function (sx, sy, sz) {
        sz = isNaN(sz) ? 1 : sz;
        if (sx == 1 && sy == 1 && sz == 1) {
            return this;
        }
        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
    };
    TransformMatrixAlgorithm.prototype.setTransform = function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        this.props[0] = a;
        this.props[1] = b;
        this.props[2] = c;
        this.props[3] = d;
        this.props[4] = e;
        this.props[5] = f;
        this.props[6] = g;
        this.props[7] = h;
        this.props[8] = i;
        this.props[9] = j;
        this.props[10] = k;
        this.props[11] = l;
        this.props[12] = m;
        this.props[13] = n;
        this.props[14] = o;
        this.props[15] = p;
        return this;
    };
    TransformMatrixAlgorithm.prototype.translate = function (tx, ty, tz) {
        tz = isNaN(tz) ? 0 : tz;
        if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
        }
        return this;
    };
    TransformMatrixAlgorithm.prototype._t = function (a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
        this.transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2);
    };
    TransformMatrixAlgorithm.prototype.transform = function (a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
        if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
            if (m2 !== 0 || n2 !== 0 || o2 !== 0) {
                this.props[12] = this.props[12] * a2 + this.props[13] * e2 + this.props[14] * i2 + this.props[15] * m2;
                this.props[13] = this.props[12] * b2 + this.props[13] * f2 + this.props[14] * j2 + this.props[15] * n2;
                this.props[14] = this.props[12] * c2 + this.props[13] * g2 + this.props[14] * k2 + this.props[15] * o2;
                this.props[15] = this.props[12] * d2 + this.props[13] * h2 + this.props[14] * l2 + this.props[15] * p2;
            }
            return this;
        }
        var a1 = this.props[0];
        var b1 = this.props[1];
        var c1 = this.props[2];
        var d1 = this.props[3];
        var e1 = this.props[4];
        var f1 = this.props[5];
        var g1 = this.props[6];
        var h1 = this.props[7];
        var i1 = this.props[8];
        var j1 = this.props[9];
        var k1 = this.props[10];
        var l1 = this.props[11];
        var m1 = this.props[12];
        var n1 = this.props[13];
        var o1 = this.props[14];
        var p1 = this.props[15];
        /* matrix order (canvas compatible):
         * ace
         * bdf
         * 001
         */
        this.props[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
        this.props[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
        this.props[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
        this.props[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
        this.props[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
        this.props[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
        this.props[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
        this.props[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
        this.props[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
        this.props[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
        this.props[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
        this.props[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
        this.props[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
        this.props[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
        this.props[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
        this.props[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
        return this;
    };
    TransformMatrixAlgorithm.prototype.clone = function (matr) {
        var i;
        for (i = 0; i < 16; i += 1) {
            matr.props[i] = this.props[i];
        }
    };
    TransformMatrixAlgorithm.prototype.cloneFromProps = function (props) {
        var i;
        for (i = 0; i < 16; i += 1) {
            this.props[i] = props[i];
        }
    };
    TransformMatrixAlgorithm.prototype.applyToPoint = function (x, y, z) {
        return {
            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
        };
        /*return {
         x: x * me.a + y * me.c + me.e,
         y: x * me.b + y * me.d + me.f
         };*/
    };
    TransformMatrixAlgorithm.prototype.applyToX = function (x, y, z) {
        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
    };
    TransformMatrixAlgorithm.prototype.applyToY = function (x, y, z) {
        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
    };
    TransformMatrixAlgorithm.prototype.applyToZ = function (x, y, z) {
        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
    };
    TransformMatrixAlgorithm.prototype.applyToPointArray = function (x, y, z) {
        return [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
    };
    TransformMatrixAlgorithm.prototype.applyToPointStringified = function (x, y) {
        return (Math.round(x * this.props[0] + y * this.props[4] + this.props[12])) + ',' + (Math.round(x * this.props[1] + y * this.props[5] + this.props[13]));
    };
    return TransformMatrixAlgorithm;
}());
var TransformMatrix = /** @class */ (function () {
    function TransformMatrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1.0; }
        if (b === void 0) { b = 0.0; }
        if (c === void 0) { c = 0.0; }
        if (d === void 0) { d = 1.0; }
        if (tx === void 0) { tx = 0.0; }
        if (ty === void 0) { ty = 0.0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    }
    TransformMatrix.unmatrix = function (matrix) {
        var A = matrix.a;
        var B = matrix.b;
        var C = matrix.c;
        var D = matrix.d;
        if (A * D == B * C) {
            return { scale: { x: 1.0, y: 1.0 }, degree: 0.0, translate: { x: 0.0, y: 0.0 } };
        }
        // step (3)
        var scaleX = Math.sqrt(A * A + B * B);
        A /= scaleX;
        B /= scaleX;
        // step (4)
        var skew = A * C + B * D;
        C -= A * skew;
        D -= B * skew;
        // step (5)
        var scaleY = Math.sqrt(C * C + D * D);
        C /= scaleY;
        D /= scaleY;
        skew /= scaleY;
        // step (6)
        if (A * D < B * C) {
            A = -A;
            B = -B;
            skew = -skew;
            scaleX = -scaleX;
        }
        return { scale: { x: scaleX, y: scaleY }, degree: Math.atan2(B, A) / (Math.PI / 180), translate: { x: matrix.tx, y: matrix.ty } };
    };
    TransformMatrix.postScale = function (matrix, x, y) {
        var obj = new TransformMatrixAlgorithm();
        var unMatrix = this.unmatrix(matrix);
        obj.rotate(-(unMatrix.degree * Math.PI / 180));
        obj.scale(unMatrix.scale.x, unMatrix.scale.y, 1.0);
        obj.translate(unMatrix.translate.x, unMatrix.translate.y, 0.0);
        obj.scale((x || 1.0), (y || 1.0), 1.0);
        return new TransformMatrix(obj.props[0], obj.props[1], obj.props[4], obj.props[5], obj.props[12], obj.props[13]);
    };
    TransformMatrix.postTranslate = function (matrix, x, y) {
        var obj = new TransformMatrixAlgorithm();
        var unMatrix = this.unmatrix(matrix);
        obj.rotate(-(unMatrix.degree * Math.PI / 180));
        obj.scale(unMatrix.scale.x, unMatrix.scale.y, 1.0);
        obj.translate(unMatrix.translate.x, unMatrix.translate.y, 0.0);
        obj.translate((x || 0.0), (y || 0.0), 0.0);
        return new TransformMatrix(obj.props[0], obj.props[1], obj.props[4], obj.props[5], obj.props[12], obj.props[13]);
    };
    TransformMatrix.postRotate = function (matrix, angle) {
        var obj = new TransformMatrixAlgorithm();
        var unMatrix = this.unmatrix(matrix);
        obj.rotate(-(unMatrix.degree * Math.PI / 180));
        obj.scale(unMatrix.scale.x, unMatrix.scale.y, 1.0);
        obj.translate(unMatrix.translate.x, unMatrix.translate.y, 0.0);
        obj.rotate(-angle);
        return new TransformMatrix(obj.props[0], obj.props[1], obj.props[4], obj.props[5], obj.props[12], obj.props[13]);
    };
    TransformMatrix.concat = function (preMatrix, postMatrix) {
        var obj = new TransformMatrixAlgorithm();
        obj.props[0] = preMatrix.a;
        obj.props[1] = preMatrix.b;
        obj.props[4] = preMatrix.c;
        obj.props[5] = preMatrix.d;
        obj.props[12] = preMatrix.tx;
        obj.props[13] = preMatrix.ty;
        obj.transform(postMatrix.a, postMatrix.b, 0, 0, postMatrix.c, postMatrix.d, 0, 0, 0, 0, 1, 0, postMatrix.tx, postMatrix.ty, 0, 1);
        return new TransformMatrix(obj.props[0], obj.props[1], obj.props[4], obj.props[5], obj.props[12], obj.props[13]);
    };
    return TransformMatrix;
}());
exports.TransformMatrix = TransformMatrix;


/***/ }),

/***/ 18:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 19:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DeviceOrientation;
(function (DeviceOrientation) {
    DeviceOrientation[DeviceOrientation["Unknown"] = 0] = "Unknown";
    DeviceOrientation[DeviceOrientation["Portrait"] = 1] = "Portrait";
    DeviceOrientation[DeviceOrientation["PortraitUpsideDown"] = 2] = "PortraitUpsideDown";
    DeviceOrientation[DeviceOrientation["LandscapeLeft"] = 3] = "LandscapeLeft";
    DeviceOrientation[DeviceOrientation["LandscapeRight"] = 4] = "LandscapeRight";
    DeviceOrientation[DeviceOrientation["FaceUp"] = 5] = "FaceUp";
    DeviceOrientation[DeviceOrientation["FaceDown"] = 6] = "FaceDown";
})(DeviceOrientation = exports.DeviceOrientation || (exports.DeviceOrientation = {}));
var Device = /** @class */ (function () {
    function Device() {
    }
    Device.prototype.isiOS = function () { return false; };
    Device.prototype.isAndroid = function () { return false; };
    Device.prototype.isWeb = function () { return false; };
    return Device;
}());
exports.Device = Device;


/***/ }),

/***/ 22:
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 23:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LayoutAttribute;
(function (LayoutAttribute) {
    LayoutAttribute[LayoutAttribute["Const"] = 0] = "Const";
    LayoutAttribute[LayoutAttribute["Left"] = 1] = "Left";
    LayoutAttribute[LayoutAttribute["Right"] = 2] = "Right";
    LayoutAttribute[LayoutAttribute["Top"] = 3] = "Top";
    LayoutAttribute[LayoutAttribute["Bottom"] = 4] = "Bottom";
    LayoutAttribute[LayoutAttribute["Width"] = 7] = "Width";
    LayoutAttribute[LayoutAttribute["Height"] = 8] = "Height";
    LayoutAttribute[LayoutAttribute["CenterX"] = 9] = "CenterX";
    LayoutAttribute[LayoutAttribute["CenterY"] = 10] = "CenterY";
})(LayoutAttribute = exports.LayoutAttribute || (exports.LayoutAttribute = {}));
var LayoutRelation;
(function (LayoutRelation) {
    LayoutRelation[LayoutRelation["Less"] = -1] = "Less";
    LayoutRelation[LayoutRelation["Equal"] = 0] = "Equal";
    LayoutRelation[LayoutRelation["Greater"] = 1] = "Greater";
})(LayoutRelation = exports.LayoutRelation || (exports.LayoutRelation = {}));
var LayoutConstraint = /** @class */ (function () {
    function LayoutConstraint(firstItem, firstAttr, relation, secondItem, secondAttr, constant, multiplier) {
        if (constant === void 0) { constant = 0; }
        if (multiplier === void 0) { multiplier = 1; }
        this.relation = LayoutRelation.Equal;
        this.constant = 0;
        this.multiplier = 1;
        this.priority = 750;
        this.firstItem = firstItem;
        this.firstAttr = firstAttr;
        this.relation = relation || LayoutRelation.Equal;
        this.secondItem = secondItem;
        this.secondAttr = secondAttr;
        this.constant = constant;
        this.multiplier = multiplier;
    }
    LayoutConstraint.constraintsWithVisualFormat = function (format, views) { return []; };
    LayoutConstraint.LayoutAttribute = LayoutAttribute;
    LayoutConstraint.LayoutRelation = LayoutRelation;
    return LayoutConstraint;
}());
exports.LayoutConstraint = LayoutConstraint;


/***/ }),

/***/ 24:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ScrollView_1 = __webpack_require__(37);
var View_1 = __webpack_require__(4);
var ListSelectionStyle;
(function (ListSelectionStyle) {
    ListSelectionStyle[ListSelectionStyle["None"] = 0] = "None";
    ListSelectionStyle[ListSelectionStyle["Gray"] = 1] = "Gray";
})(ListSelectionStyle = exports.ListSelectionStyle || (exports.ListSelectionStyle = {}));
var ListCell = /** @class */ (function (_super) {
    __extends(ListCell, _super);
    function ListCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.selectionStyle = ListSelectionStyle.Gray;
        return _this;
    }
    ListCell.prototype.didSelected = function () { };
    ListCell.prototype.didRender = function () { };
    return ListCell;
}(View_1.View));
exports.ListCell = ListCell;
var ListView = /** @class */ (function (_super) {
    __extends(ListView, _super);
    function ListView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListView.prototype.register = function (clazz, reuseIdentifier) { };
    ListView.prototype.reloadData = function () { };
    return ListView;
}(ScrollView_1.ScrollView));
exports.ListView = ListView;


/***/ }),

/***/ 260:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var main_android_1 = __webpack_require__(261);
var AppDelegate = /** @class */ (function (_super) {
    __extends(AppDelegate, _super);
    function AppDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AppDelegate.prototype.applicationDidFinishLaunchingWithOptions = function () {
        this.window = new main_android_1.Window();
        this.window.rootViewController = new main_android_1.NavigationController(new FirstViewController());
        this.window.makeKeyAndVisible();
    };
    return AppDelegate;
}(main_android_1.ApplicationDelegate));
var FirstViewController = /** @class */ (function (_super) {
    __extends(FirstViewController, _super);
    function FirstViewController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FirstViewController.prototype.viewDidLoad = function () {
        this.supportOrientations = [main_android_1.DeviceOrientation.Portrait, main_android_1.DeviceOrientation.LandscapeLeft, main_android_1.DeviceOrientation.LandscapeRight];
        var redView = new main_android_1.View(main_android_1.RectMake(0, 0, 44, 44));
        redView.transform = new main_android_1.TransformMatrix(1.0, 0.0, 0.0, 1.0, 44.0, 44.0);
        redView.backgroundColor = main_android_1.Color.redColor;
        redView.userInteractionEnabled = true;
        redView.onTap = function () {
            redView.backgroundColor = main_android_1.Color.blueColor;
        };
        this.view.backgroundColor = main_android_1.Color.yellowColor;
        this.view.addSubview(redView);
    };
    return FirstViewController;
}(main_android_1.ViewController));
var application = new main_android_1.Application('app', new AppDelegate());


/***/ }),

/***/ 261:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Application_1 = __webpack_require__(262);
var ApplicationDelegate = /** @class */ (function (_super) {
    __extends(ApplicationDelegate, _super);
    function ApplicationDelegate() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ApplicationDelegate;
}(Application_1.ApplicationDelegate));
exports.ApplicationDelegate = ApplicationDelegate;
var Application = /** @class */ (function (_super) {
    __extends(Application, _super);
    function Application() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Application;
}(Application_1.Application));
exports.Application = Application;
var Button_1 = __webpack_require__(121);
var Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    function Button() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Button;
}(Button_1.Button));
exports.Button = Button;
var Color_1 = __webpack_require__(6);
var Color = /** @class */ (function (_super) {
    __extends(Color, _super);
    function Color() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Color;
}(Color_1.Color));
exports.Color = Color;
var Font_1 = __webpack_require__(36);
var Font = /** @class */ (function (_super) {
    __extends(Font, _super);
    function Font() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Font;
}(Font_1.Font));
exports.Font = Font;
var ImageView_1 = __webpack_require__(27);
var ImageView_2 = __webpack_require__(62);
exports.ImageRenderingMode = ImageView_1.ImageRenderingMode;
var Image = /** @class */ (function (_super) {
    __extends(Image, _super);
    function Image() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Image;
}(ImageView_2.Image));
exports.Image = Image;
exports.ContentMode = ImageView_1.ContentMode;
var ImageView = /** @class */ (function (_super) {
    __extends(ImageView, _super);
    function ImageView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ImageView;
}(ImageView_2.ImageView));
exports.ImageView = ImageView;
var Label_1 = __webpack_require__(14);
var Label_2 = __webpack_require__(122);
exports.TextAlignment = Label_1.TextAlignment;
exports.TextVerticalAlignment = Label_1.TextVerticalAlignment;
exports.LineBreakMode = Label_1.LineBreakMode;
var Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    function Label() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Label;
}(Label_2.Label));
exports.Label = Label;
var LayoutConstraint_1 = __webpack_require__(23);
var LayoutConstraint_2 = __webpack_require__(263);
exports.LayoutAttribute = LayoutConstraint_1.LayoutAttribute;
exports.LayoutRelation = LayoutConstraint_1.LayoutRelation;
var LayoutConstraint = /** @class */ (function (_super) {
    __extends(LayoutConstraint, _super);
    function LayoutConstraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LayoutConstraint;
}(LayoutConstraint_2.LayoutConstraint));
exports.LayoutConstraint = LayoutConstraint;
var ListView_1 = __webpack_require__(24);
var ListView_2 = __webpack_require__(264);
exports.ListSelectionStyle = ListView_1.ListSelectionStyle;
var ListCell = /** @class */ (function (_super) {
    __extends(ListCell, _super);
    function ListCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ListCell;
}(ListView_2.ListCell));
exports.ListCell = ListCell;
var ListView = /** @class */ (function (_super) {
    __extends(ListView, _super);
    function ListView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ListView;
}(ListView_2.ListView));
exports.ListView = ListView;
var Rect_1 = __webpack_require__(0);
exports.PointMake = Rect_1.PointMake;
exports.PointEqual = Rect_1.PointEqual;
exports.PointZero = Rect_1.PointZero;
exports.SizeMake = Rect_1.SizeMake;
exports.SizeEqual = Rect_1.SizeEqual;
exports.SizeZero = Rect_1.SizeZero;
exports.RectMake = Rect_1.RectMake;
exports.RectZero = Rect_1.RectZero;
exports.RectEqual = Rect_1.RectEqual;
exports.RectInside = Rect_1.RectInside;
var Screen_1 = __webpack_require__(15);
var Screen = /** @class */ (function (_super) {
    __extends(Screen, _super);
    function Screen() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Screen;
}(Screen_1.Screen));
exports.Screen = Screen;
var ScrollView_1 = __webpack_require__(123);
var ScrollView = /** @class */ (function (_super) {
    __extends(ScrollView, _super);
    function ScrollView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ScrollView;
}(ScrollView_1.ScrollView));
exports.ScrollView = ScrollView;
var TransformMatrix_1 = __webpack_require__(16);
var TransformMatrix = /** @class */ (function (_super) {
    __extends(TransformMatrix, _super);
    function TransformMatrix() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TransformMatrix;
}(TransformMatrix_1.TransformMatrix));
exports.TransformMatrix = TransformMatrix;
var View_1 = __webpack_require__(4);
var View_2 = __webpack_require__(9);
var View = /** @class */ (function (_super) {
    __extends(View, _super);
    function View() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return View;
}(View_2.View));
exports.View = View;
exports.InteractionState = View_1.InteractionState;
exports.SwipeDirection = View_1.SwipeDirection;
var Window_1 = __webpack_require__(265);
var Window = /** @class */ (function (_super) {
    __extends(Window, _super);
    function Window() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Window;
}(Window_1.Window));
exports.Window = Window;
var ViewController_1 = __webpack_require__(124);
var ViewController = /** @class */ (function (_super) {
    __extends(ViewController, _super);
    function ViewController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ViewController;
}(ViewController_1.ViewController));
exports.ViewController = ViewController;
var NavigationController_1 = __webpack_require__(266);
var NavigationController = /** @class */ (function (_super) {
    __extends(NavigationController, _super);
    function NavigationController() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NavigationController;
}(NavigationController_1.NavigationController));
exports.NavigationController = NavigationController;
var TextField_1 = __webpack_require__(61);
var TextField_2 = __webpack_require__(267);
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextField;
}(TextField_2.TextField));
exports.TextField = TextField;
exports.TextFieldViewMode = TextField_1.TextFieldViewMode;
exports.ReturnKeyType = TextField_1.ReturnKeyType;
exports.KeyboardType = TextField_1.KeyboardType;
var TextView_1 = __webpack_require__(268);
var TextView = /** @class */ (function (_super) {
    __extends(TextView, _super);
    function TextView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TextView;
}(TextView_1.TextView));
exports.TextView = TextView;
var CanvasView_1 = __webpack_require__(269);
var CanvasView = /** @class */ (function (_super) {
    __extends(CanvasView, _super);
    function CanvasView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CanvasView;
}(CanvasView_1.CanvasView));
exports.CanvasView = CanvasView;
var CustomView_1 = __webpack_require__(270);
var CustomView = /** @class */ (function (_super) {
    __extends(CustomView, _super);
    function CustomView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CustomView;
}(CustomView_1.CustomView));
exports.CustomView = CustomView;
var Device_1 = __webpack_require__(19);
var Device_2 = __webpack_require__(125);
exports.DeviceOrientation = Device_1.DeviceOrientation;
var Device = /** @class */ (function (_super) {
    __extends(Device, _super);
    function Device() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Device;
}(Device_2.Device));
exports.Device = Device;


/***/ }),

/***/ 262:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var sharedApplication = undefined;
var ApplicationDelegate = /** @class */ (function () {
    function ApplicationDelegate(nativeObject) {
        this.nativeObject = nativeObject || XTRApplicationDelegate.create(this);
        window.XTRObjCreater.store(this);
    }
    Object.defineProperty(ApplicationDelegate.prototype, "window", {
        get: function () {
            return this.nativeObject.xtr_window();
        },
        set: function (value) {
            this.nativeObject.xtr_setWindow(value);
        },
        enumerable: true,
        configurable: true
    });
    ApplicationDelegate.prototype.applicationDidFinishLaunchingWithOptions = function (application, launchOptions) { };
    return ApplicationDelegate;
}());
exports.ApplicationDelegate = ApplicationDelegate;
var Application = /** @class */ (function () {
    function Application(t, delegate, nativeObject) {
        if (nativeObject) {
            this.nativeObject = nativeObject;
            window.XTRObjCreater.store(this);
            return;
        }
        if (sharedApplication === undefined) {
            sharedApplication = this;
        }
        this.nativeObject = XTRApplication.create(this);
        XTRAppRef = this;
        window.XTRObjCreater.store(this);
        this.nativeObject.xtr_setDelegate(delegate);
        this.delegate = delegate;
    }
    Object.defineProperty(Application.prototype, "keyWindow", {
        get: function () {
            return this.nativeObject.xtr_keyWindow;
        },
        enumerable: true,
        configurable: true
    });
    Application.sharedApplication = function () {
        return sharedApplication;
    };
    return Application;
}());
exports.Application = Application;
if (window.XTRObjCreater === undefined) {
    window.XTRObjCreater = {
        create: function (view) {
            if (this.objectStore[view.objectUUID.toString()] !== undefined) {
                return this.objectStore[view.objectUUID.toString()];
            }
            for (var index = 0; index < window.XTRObjClasses.length; index++) {
                var element = window.XTRObjClasses[index];
                var instance = element(view);
                if (instance !== undefined) {
                    this.store(instance);
                    return instance;
                }
            }
            return view;
        },
        store: function (target) {
            if (typeof target.objectUUID === "string") {
                this.objectStore[target.objectUUID] = target;
            }
        },
        objectStore: {},
    };
}
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRApplication$InnerObject") === 0) {
        return new Application(undefined, undefined, view);
    }
    else if (view.toString().indexOf("com.opensource.xtruntime.XTRApplicationDelegate$InnerObject") === 0) {
        return new ApplicationDelegate(view);
    }
    return undefined;
});


/***/ }),

/***/ 263:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var LayoutConstraint_1 = __webpack_require__(23);
var AutoLayout = __webpack_require__(35);
var LayoutConstraint = /** @class */ (function (_super) {
    __extends(LayoutConstraint, _super);
    function LayoutConstraint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LayoutConstraint.fromALObject = function (obj, views) {
        var toAttr = function (attr) {
            if (attr == "const") {
                return LayoutConstraint_1.LayoutAttribute.Const;
            }
            if (attr == "left") {
                return LayoutConstraint_1.LayoutAttribute.Left;
            }
            if (attr == "right") {
                return LayoutConstraint_1.LayoutAttribute.Right;
            }
            if (attr == "top") {
                return LayoutConstraint_1.LayoutAttribute.Top;
            }
            if (attr == "bottom") {
                return LayoutConstraint_1.LayoutAttribute.Bottom;
            }
            if (attr == "width") {
                return LayoutConstraint_1.LayoutAttribute.Width;
            }
            if (attr == "height") {
                return LayoutConstraint_1.LayoutAttribute.Height;
            }
            if (attr == "centerX") {
                return LayoutConstraint_1.LayoutAttribute.CenterX;
            }
            if (attr == "centerY") {
                return LayoutConstraint_1.LayoutAttribute.CenterY;
            }
        };
        var toLayoutRelation = function (rel) {
            if (rel == "leq") {
                return LayoutConstraint_1.LayoutRelation.Less;
            }
            if (rel == "geq") {
                return LayoutConstraint_1.LayoutRelation.Greater;
            }
            return LayoutConstraint_1.LayoutRelation.Equal;
        };
        var constant = obj.constant == "default" ? 8 : parseInt(obj.constant);
        var layoutConstraint = new LayoutConstraint(views[obj.view1], toAttr(obj.attr1), toLayoutRelation(obj.relation), views[obj.view2], toAttr(obj.attr2), constant, obj.multiplier);
        layoutConstraint.priority = obj.priority || 750;
        return layoutConstraint;
    };
    LayoutConstraint.constraintsWithVisualFormat = function (format, views) {
        try {
            var result = AutoLayout.VisualFormat.parse(format);
            return result.map(function (item) {
                return LayoutConstraint.fromALObject(item, views);
            });
        }
        catch (error) {
            console.error(error);
            return [];
        }
    };
    LayoutConstraint.prototype.toALObject = function () {
        var toAttr = function (attr) {
            if (attr == LayoutConstraint_1.LayoutAttribute.Const) {
                return "const";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Left) {
                return "left";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Right) {
                return "right";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Top) {
                return "top";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Bottom) {
                return "bottom";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Width) {
                return "width";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.Height) {
                return "height";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.CenterX) {
                return "centerX";
            }
            if (attr == LayoutConstraint_1.LayoutAttribute.CenterY) {
                return "centerY";
            }
            return undefined;
        };
        var toLayoutRelation = function (rel) {
            if (rel == LayoutConstraint_1.LayoutRelation.Equal) {
                return "equ";
            }
            else if (rel == LayoutConstraint_1.LayoutRelation.Less) {
                return "leq";
            }
            else if (rel == LayoutConstraint_1.LayoutRelation.Greater) {
                return "geq";
            }
            return "equ";
        };
        return {
            view1: this.firstItem !== undefined ? this.firstItem.objectUUID : undefined,
            attr1: toAttr(this.firstAttr),
            relation: toLayoutRelation(this.relation),
            view2: this.secondItem !== undefined ? this.secondItem.objectUUID : undefined,
            attr2: toAttr(this.secondAttr),
            multiplier: this.multiplier,
            constant: this.constant,
            priority: this.priority,
        };
    };
    return LayoutConstraint;
}(LayoutConstraint_1.LayoutConstraint));
exports.LayoutConstraint = LayoutConstraint;


/***/ }),

/***/ 264:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ScrollView_1 = __webpack_require__(123);
var View_1 = __webpack_require__(9);
var ListView_1 = __webpack_require__(24);
var Color_1 = __webpack_require__(6);
var View_2 = __webpack_require__(4);
var ListCell = /** @class */ (function (_super) {
    __extends(ListCell, _super);
    function ListCell() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.reuseIdentifier = "";
        _this.selectionStyle = ListView_1.ListSelectionStyle.Gray;
        _this._isBusy = false;
        return _this;
    }
    ListCell.prototype.init = function () {
        var _this = this;
        _super.prototype.init.call(this);
        this.selectionView = new View_1.View();
        this.contentView = new View_1.View();
        this.selectionView.backgroundColor = new Color_1.Color(0xd0 / 0xff, 0xd0 / 0xff, 0xd0 / 0xff);
        this.selectionView.alpha = 0.0;
        this.addSubview(this.selectionView);
        this.addSubview(this.contentView);
        this.userInteractionEnabled = true;
        this.longPressDuration = 0.05;
        this.onTap = function () {
            _this.highligted = true;
            _this.onSelected && _this.onSelected();
            _this.didSelected();
            View_1.View.animationWithDuration(0.15, function () {
                _this.highligted = false;
            });
        };
        this.onLongPress = function (state) {
            if (state == View_2.InteractionState.Began) {
                _this.highligted = true;
            }
            else if (state == View_2.InteractionState.Ended) {
                _this.onSelected && _this.onSelected();
                _this.didSelected();
                View_1.View.animationWithDuration(0.15, function () {
                    _this.highligted = false;
                });
            }
            else if (state == View_2.InteractionState.Cancelled) {
                _this.highligted = false;
            }
        };
    };
    ListCell.prototype.layoutSubviews = function () {
        _super.prototype.layoutSubviews.call(this);
        this.selectionView.frame = this.bounds;
        this.contentView.frame = this.bounds;
    };
    Object.defineProperty(ListCell.prototype, "highligted", {
        set: function (value) {
            if (this.selectionStyle == ListView_1.ListSelectionStyle.None) {
                return;
            }
            this.selectionView.alpha = value ? 1.0 : 0.0;
        },
        enumerable: true,
        configurable: true
    });
    ListCell.prototype.didSelected = function () { };
    ListCell.prototype.didRender = function () { };
    return ListCell;
}(View_1.View));
exports.ListCell = ListCell;
var ListView = /** @class */ (function (_super) {
    __extends(ListView, _super);
    function ListView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.reuseMapping = {};
        _this._items = [];
        _this._cacheRows = [];
        _this._reusingCells = [];
        _this._nextSetted = false;
        _this._nextReloadMinY = undefined;
        _this._nextReloadMaxY = undefined;
        return _this;
    }
    ListView.prototype.init = function () {
        _super.prototype.init.call(this);
        this.alwaysBounceVertical = true;
    };
    ListView.prototype.register = function (clazz, reuseIdentifier) {
        this.reuseMapping[reuseIdentifier] = clazz;
    };
    Object.defineProperty(ListView.prototype, "items", {
        get: function () {
            return this._items.slice();
        },
        set: function (value) {
            this._items = value.slice();
        },
        enumerable: true,
        configurable: true
    });
    ListView.prototype.reloadData = function () {
        var _this = this;
        var currentY = 0;
        this._cacheRows = this.items.map(function (item) {
            var minY = currentY;
            var maxY = minY + item.rowHeight(_this.bounds.width);
            currentY = maxY;
            return { minY: minY, maxY: maxY, item: item };
        });
        this.contentSize = { width: 0, height: currentY };
        this._nextSetted = false;
        this._nextReloadMinY = undefined;
        this._nextReloadMaxY = undefined;
        this.reloadVisibleRows();
    };
    ListView.prototype.layoutSubviews = function () {
        _super.prototype.layoutSubviews.call(this);
        this.reloadData();
    };
    ListView.prototype.handleScroll = function (x, y) {
        _super.prototype.handleScroll.call(this, x, y);
        if (this._reusingCells !== undefined) {
            this.reloadVisibleRows();
        }
    };
    ListView.prototype.reloadVisibleRows = function () {
        var _this = this;
        var contentOffset = this.contentOffset;
        var bounds = this.bounds;
        if (contentOffset.y < 0 || contentOffset.y + bounds.height > this.contentSize.height) {
            return;
        }
        if (this._nextSetted === true &&
            (this._nextReloadMinY !== undefined && this.contentOffset.y > (this._nextReloadMinY || -Infinity)) &&
            (this._nextReloadMaxY !== undefined && this.contentOffset.y < (this._nextReloadMaxY || Infinity))) {
            return;
        }
        this.markInvisibleCellNoBusy();
        this._nextSetted = true;
        this._nextReloadMinY = undefined;
        this._nextReloadMaxY = undefined;
        var visibleRows = [];
        var startIndex = 0;
        var left = 0;
        var right = this._cacheRows.length - 1;
        while (true) {
            if (Math.abs(right - left) <= 1) {
                startIndex = left;
                break;
            }
            var mid = Math.ceil((right + left) / 2);
            if (this._cacheRows[mid].minY <= contentOffset.y && this._cacheRows[mid].maxY >= contentOffset.y) {
                startIndex = mid;
                break;
            }
            else if (this._cacheRows[mid].maxY < contentOffset.y) {
                left = mid;
            }
            else if (this._cacheRows[mid].minY > contentOffset.y) {
                right = mid;
            }
        }
        if (startIndex > 0) {
            this._nextReloadMinY = this._cacheRows[startIndex - 1].maxY;
        }
        else {
            this._nextReloadMinY = 0;
        }
        for (var index = startIndex; index < this._cacheRows.length; index++) {
            var item = this._cacheRows[index];
            if (this._nextReloadMaxY === undefined && item.minY >= this.contentOffset.y + this.bounds.height) {
                this._nextReloadMaxY = item.minY - this.bounds.height;
            }
            if (item.maxY > this.contentOffset.y && item.minY < this.contentOffset.y + this.bounds.height) {
                visibleRows.push(item);
            }
            else if (item.minY > this.contentOffset.y + this.bounds.height) {
                break;
            }
        }
        var visibleCells = visibleRows.filter(function (row) { return _this._reusingCells.filter(function (cell) { return cell.currentItem === row.item; }).length == 0; }).map(function (row) {
            var cell = _this._reusingCells.filter(function (cell) {
                return !cell._isBusy && cell.reuseIdentifier === row.item.reuseIdentifier;
            })[0] ||
                (_this.reuseMapping[row.item.reuseIdentifier] !== undefined ? new _this.reuseMapping[row.item.reuseIdentifier]() : undefined) ||
                new ListCell();
            cell.reuseIdentifier = row.item.reuseIdentifier;
            cell.frame = { x: 0, y: row.minY, width: _this.bounds.width, height: row.maxY - row.minY };
            cell._isBusy = true;
            cell.currentItem = row.item;
            _this.renderItem && _this.renderItem(cell, row.item);
            cell.onRender && cell.onRender();
            cell.didRender();
            if (_this._reusingCells.indexOf(cell) < 0) {
                _this._reusingCells.push(cell);
            }
            return cell;
        });
        visibleCells.forEach(function (cell) {
            if (cell.superview === undefined) {
                _this.addSubview(cell);
            }
        });
    };
    ListView.prototype.markInvisibleCellNoBusy = function () {
        var _this = this;
        this._reusingCells.filter(function (cell) {
            return cell._isBusy && (cell.frame.y + cell.frame.height < _this.contentOffset.y || cell.frame.y > _this.contentOffset.y + _this.bounds.height);
        }).forEach(function (cell) {
            cell._isBusy = false;
        });
    };
    return ListView;
}(ScrollView_1.ScrollView));
exports.ListView = ListView;


/***/ }),

/***/ 265:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="xtr.d.ts" />
var Rect_1 = __webpack_require__(0);
var View_1 = __webpack_require__(9);
var Window = /** @class */ (function (_super) {
    __extends(Window, _super);
    function Window(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRWindow.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(Window.prototype, "rootViewController", {
        get: function () {
            return this.nativeObject.xtr_rootViewController();
        },
        set: function (value) {
            this.nativeObject.xtr_setRootViewController(value);
        },
        enumerable: true,
        configurable: true
    });
    Window.prototype.makeKeyAndVisible = function () {
        this.nativeObject.xtr_makeKeyAndVisible();
    };
    Window.prototype.handleKeyboardShow = function (frame, duration) {
        this.rootViewController && this.rootViewController.keyboardWillShow(frame, duration);
    };
    Window.prototype.handleKeyboardHide = function (duration) {
        this.rootViewController && this.rootViewController.keyboardWillHide(duration);
    };
    Window.prototype.handleOrientationChange = function () {
        this.rootViewController && this.rootViewController.orientationDidChange(this);
    };
    Window.prototype.handleStatusBarHidden = function (hidden) {
        this.nativeObject.xtr_setStatusBarHidden(hidden === true);
    };
    Window.prototype.endEditing = function () {
        this.nativeObject.xtr_endEditing();
    };
    return Window;
}(View_1.View));
exports.Window = Window;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRWindow$InnerObject") === 0) {
        return new Window(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 266:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ViewController_1 = __webpack_require__(124);
var View_1 = __webpack_require__(9);
var NavigationController = /** @class */ (function (_super) {
    __extends(NavigationController, _super);
    function NavigationController(rootViewController, nativeObject, isChild) {
        if (isChild === void 0) { isChild = false; }
        var _this = _super.call(this, nativeObject, true) || this;
        _this.className = "NavigationController";
        if (isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRNavigationController.createScriptObject(_this);
            window.XTRObjCreater.store(_this);
            _this.loadView();
            if (rootViewController) {
                _this.nativeObject.xtr_setViewControllersAnimated([rootViewController], false);
            }
        }
        return _this;
    }
    NavigationController.prototype.loadView = function () {
        this.view = new View_1.View();
        this.view.userInteractionEnabled = true;
    };
    NavigationController.prototype.pushViewController = function (viewController, animated) {
        if (animated === void 0) { animated = true; }
        this.nativeObject.xtr_pushViewController(viewController, animated);
    };
    NavigationController.prototype.popViewController = function (animated) {
        if (animated === void 0) { animated = true; }
        return this.nativeObject.xtr_popViewController(animated);
    };
    NavigationController.prototype.popToViewController = function (viewController, animated) {
        if (animated === void 0) { animated = true; }
        return this.nativeObject.xtr_popToViewController(viewController, animated);
    };
    NavigationController.prototype.popToRootViewController = function (animated) {
        if (animated === void 0) { animated = true; }
        return this.nativeObject.xtr_popToRootViewController(animated);
    };
    return NavigationController;
}(ViewController_1.ViewController));
exports.NavigationController = NavigationController;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (target) {
    if (target.toString().indexOf("com.opensource.xtruntime.XTRNavigationController$InnerObject") === 0) {
        return new NavigationController(undefined, target);
    }
    return undefined;
});


/***/ }),

/***/ 267:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/// <reference path="xtr.d.ts" />
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var Button_1 = __webpack_require__(121);
var ImageView_1 = __webpack_require__(62);
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        _this.shouldBeginEditing = undefined;
        _this.didBeginEditing = undefined;
        _this.shouldEndEditing = undefined;
        _this.didEndEditing = undefined;
        _this.shouldChange = undefined;
        _this.shouldClear = undefined;
        _this.shouldReturn = undefined;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRTextField.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(TextField.prototype, "text", {
        get: function () {
            return this.nativeObject.xtr_text();
        },
        set: function (value) {
            this.nativeObject.xtr_setText(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "font", {
        get: function () {
            return this.nativeObject.xtr_font();
        },
        set: function (value) {
            this.nativeObject.xtr_setFont(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textColor", {
        get: function () {
            return this.nativeObject.xtr_textColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textAlignment", {
        get: function () {
            return this.nativeObject.xtr_textAlignment();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextAlignment(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "placeholder", {
        get: function () {
            return this.nativeObject.xtr_placeholder();
        },
        set: function (value) {
            this.nativeObject.xtr_setPlaceholder(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "placeholderColor", {
        get: function () {
            return this.nativeObject.xtr_placeholderColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setPlaceholderColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "clearsOnBeginEditing", {
        get: function () {
            return this.nativeObject.xtr_clearsOnBeginEditing();
        },
        set: function (value) {
            this.nativeObject.xtr_setClearsOnBeginEditing(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "editing", {
        get: function () {
            return this.nativeObject.xtr_editing();
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype.requestClearView = function () {
        var _this = this;
        var view = new Button_1.Button(Rect_1.RectMake(0, 0, 36, 0));
        ImageView_1.Image.fromBase64('iVBORw0KGgoAAAANSUhEUgAAACoAAAAqCAMAAADyHTlpAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABjUExURUdwTKqqqo+OlZGRto+OlZOTmY+OlY+OlJCQlpCQlZGOlpGRnZCQmY+OlJCOlJCOlI+OlI+OlJCOlI+OlJCOlI+OlI+PlI+OlI+OlI+OlI+PlI+OlP///4+OlI+PlY+PlI+OlI/lPb8AAAAgdFJOUwAG4AfzLcP7VS5mFR7Zob+l/Y/eiPd89vXum/AB+HuJvx1C8wAAASxJREFUOMuVlUeigzAMRAWYXkMnEKL7n/LzaRaOKZoVwm+hMpYBjrLHLI2FiNNstOFCdl4gUZGf0VHyQkWvJNKARvlBjarSUMnQwRM54ZH0TTyV6R9IgRcShA1NvJS552A4eCNnq+2LtyrXflb3aLX0N5F/mp6ed638TuZpyhm9rSFwt8ANwHrLuf3PON/D1ppCb2VdbwqsZj/Mp1A6pJvzWdiZhEEmVEzdJ8kFO7uQEJBDH2oSrYDn7h/ksIYMNayGxAxS1LAaElOI8YRVSIxB9dTGqiQKDspIgFEWo1mPRzA+H6xN7dL/2AU6ahdiwubXhO3BhAdrA7X2oFqbXpi2ozX3jXJhIPo8voaMy81ZGYxFxFlvnKXJWcWcBc95NliP0VJfvT1xtVIN/AEiR40jdo0zSQAAAABJRU5ErkJggg==', 3.0, function (it) {
            view.image = it;
        });
        view.onTap = function () {
            _this.nativeObject.xtr_onClearButtonTap();
        };
        return view;
    };
    Object.defineProperty(TextField.prototype, "clearButtonMode", {
        get: function () {
            return this.nativeObject.xtr_clearButtonMode();
        },
        set: function (value) {
            this.nativeObject.xtr_setClearButtonMode(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "leftView", {
        get: function () {
            return this.nativeObject.xtr_leftView();
        },
        set: function (view) {
            this.nativeObject.xtr_setLeftView(view);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "leftViewMode", {
        get: function () {
            return this.nativeObject.xtr_leftViewMode();
        },
        set: function (value) {
            this.nativeObject.xtr_setLeftViewMode(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "rightView", {
        get: function () {
            return this.nativeObject.xtr_rightView();
        },
        set: function (view) {
            this.nativeObject.xtr_setRightView(view);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "rightViewMode", {
        get: function () {
            return this.nativeObject.xtr_rightViewMode();
        },
        set: function (value) {
            this.nativeObject.xtr_setRightViewMode(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "allowAutocapitalization", {
        get: function () {
            return this.nativeObject.xtr_allowAutocapitalization();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowAutocapitalization(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "allowAutocorrection", {
        get: function () {
            return this.nativeObject.xtr_allowAutocorrection();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowAutocorrection(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "allowSpellChecking", {
        get: function () {
            return this.nativeObject.xtr_allowSpellChecking();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowSpellChecking(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "keyboardType", {
        get: function () {
            return this.nativeObject.xtr_keyboardType();
        },
        set: function (value) {
            this.nativeObject.xtr_setKeyboardType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "returnKeyType", {
        get: function () {
            return this.nativeObject.xtr_returnKeyType();
        },
        set: function (value) {
            this.nativeObject.xtr_setReturnKeyType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "enablesReturnKeyAutomatically", {
        get: function () {
            return false;
        },
        set: function (value) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "secureTextEntry", {
        get: function () {
            return this.nativeObject.xtr_secureTextEntry;
        },
        set: function (value) {
            if (value) {
                this.allowAutocapitalization = false;
                this.allowAutocorrection = false;
                this.allowSpellChecking = false;
            }
            this.nativeObject.xtr_setSecureTextEntry(value);
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype.handleShouldBeginEditing = function () {
        if (this.shouldBeginEditing) {
            return this.shouldBeginEditing();
        }
        return true;
    };
    TextField.prototype.handleDidBeginEditing = function () {
        this.didBeginEditing && this.didBeginEditing();
    };
    TextField.prototype.handleShouldEndEditing = function () {
        if (this.shouldEndEditing) {
            return this.shouldEndEditing();
        }
        return true;
    };
    TextField.prototype.handleDidEndEditing = function () {
        this.didEndEditing && this.didEndEditing();
    };
    TextField.prototype.handleShouldChange = function (inRange, replacementString) {
        if (this.shouldChange) {
            return this.shouldChange(inRange, replacementString);
        }
        return true;
    };
    TextField.prototype.handleShouldClear = function () {
        if (this.shouldClear) {
            return this.shouldClear();
        }
        return true;
    };
    TextField.prototype.handleShouldReturn = function () {
        if (this.shouldReturn) {
            return this.shouldReturn();
        }
        return true;
    };
    TextField.prototype.focus = function () {
        this.nativeObject.xtr_focus();
    };
    TextField.prototype.blur = function () {
        this.nativeObject.xtr_blur();
    };
    return TextField;
}(View_1.View));
exports.TextField = TextField;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRTextField$InnerObject") === 0) {
        return new TextField(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 268:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
;
var TextView = /** @class */ (function (_super) {
    __extends(TextView, _super);
    function TextView(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        _this.shouldBeginEditing = undefined;
        _this.didBeginEditing = undefined;
        _this.shouldEndEditing = undefined;
        _this.didEndEditing = undefined;
        _this.shouldChange = undefined;
        _this.shouldClear = undefined;
        _this.shouldReturn = undefined;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRTextView.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(TextView.prototype, "text", {
        get: function () {
            return this.nativeObject.xtr_text();
        },
        set: function (value) {
            this.nativeObject.xtr_setText(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "font", {
        get: function () {
            return this.nativeObject.xtr_font();
        },
        set: function (value) {
            this.nativeObject.xtr_setFont(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "textColor", {
        get: function () {
            return this.nativeObject.xtr_textColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "textAlignment", {
        get: function () {
            return this.nativeObject.xtr_textAlignment();
        },
        set: function (value) {
            this.nativeObject.xtr_setTextAlignment(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "editing", {
        get: function () {
            return this.nativeObject.xtr_editing();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "allowAutocapitalization", {
        get: function () {
            return this.nativeObject.xtr_allowAutocapitalization();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowAutocapitalization(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "allowAutocorrection", {
        get: function () {
            return this.nativeObject.xtr_allowAutocorrection();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowAutocorrection(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "allowSpellChecking", {
        get: function () {
            return this.nativeObject.xtr_allowSpellChecking();
        },
        set: function (value) {
            this.nativeObject.xtr_setAllowSpellChecking(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "keyboardType", {
        get: function () {
            return this.nativeObject.xtr_keyboardType();
        },
        set: function (value) {
            this.nativeObject.xtr_setKeyboardType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "returnKeyType", {
        get: function () {
            return this.nativeObject.xtr_returnKeyType();
        },
        set: function (value) {
            this.nativeObject.xtr_setReturnKeyType(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "enablesReturnKeyAutomatically", {
        get: function () {
            return this.nativeObject.xtr_enablesReturnKeyAutomatically();
        },
        set: function (value) {
            this.nativeObject.xtr_setEnablesReturnKeyAutomatically(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextView.prototype, "secureTextEntry", {
        get: function () {
            return this.nativeObject.xtr_secureTextEntry;
        },
        set: function (value) {
            this.nativeObject.xtr_setSecureTextEntry(value);
        },
        enumerable: true,
        configurable: true
    });
    TextView.prototype.handleShouldBeginEditing = function () {
        if (this.shouldBeginEditing) {
            return this.shouldBeginEditing();
        }
        return true;
    };
    TextView.prototype.handleDidBeginEditing = function () {
        this.didBeginEditing && this.didBeginEditing();
    };
    TextView.prototype.handleShouldEndEditing = function () {
        if (this.shouldEndEditing) {
            return this.shouldEndEditing();
        }
        return true;
    };
    TextView.prototype.handleDidEndEditing = function () {
        this.didEndEditing && this.didEndEditing();
    };
    TextView.prototype.handleShouldChange = function (inRange, replacementString) {
        if (this.shouldChange) {
            return this.shouldChange(inRange, replacementString);
        }
        return true;
    };
    TextView.prototype.handleShouldClear = function () {
        if (this.shouldClear) {
            return this.shouldClear();
        }
        return true;
    };
    TextView.prototype.handleShouldReturn = function () {
        if (this.shouldReturn) {
            return this.shouldReturn();
        }
        return true;
    };
    TextView.prototype.focus = function () {
        this.nativeObject.xtr_focus();
    };
    TextView.prototype.blur = function () {
        if (!this.handleShouldEndEditing()) {
            return;
        }
        this.nativeObject.xtr_blur();
    };
    return TextView;
}(View_1.View));
exports.TextView = TextView;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.constructor.toString() === "[object XTRTextViewConstructor]") {
        return new TextView(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 269:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var CanvasView = /** @class */ (function (_super) {
    __extends(CanvasView, _super);
    function CanvasView(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRCanvasView.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            setImmediate(function () { _this.init(); });
        }
        return _this;
    }
    Object.defineProperty(CanvasView.prototype, "globalAlpha", {
        get: function () {
            return this.nativeObject.xtr_globalAlpha();
        },
        set: function (value) {
            this.nativeObject.xtr_setGlobalAlpha(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "fillStyle", {
        get: function () {
            return this.nativeObject.xtr_fillStyle();
        },
        set: function (value) {
            this.nativeObject.xtr_setFillStyle(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "strokeStyle", {
        get: function () {
            return this.nativeObject.xtr_strokeStyle();
        },
        set: function (value) {
            this.nativeObject.xtr_setStrokeStyle(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "lineCap", {
        get: function () {
            return this.nativeObject.xtr_lineCap();
        },
        set: function (value) {
            this.nativeObject.xtr_setLineCap(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "lineJoin", {
        get: function () {
            return this.nativeObject.xtr_lineJoin();
        },
        set: function (value) {
            this.nativeObject.xtr_setLineJoin(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "lineWidth", {
        get: function () {
            return this.nativeObject.xtr_lineWidth();
        },
        set: function (value) {
            this.nativeObject.xtr_setLineWidth(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CanvasView.prototype, "miterLimit", {
        get: function () {
            return this.nativeObject.xtr_miterLimit();
        },
        set: function (value) {
            this.nativeObject.xtr_setMiterLimit(value);
        },
        enumerable: true,
        configurable: true
    });
    CanvasView.prototype.rect = function (x, y, width, height) {
        this.nativeObject.xtr_rect({ x: x, y: y, width: width, height: height });
    };
    CanvasView.prototype.fillRect = function (x, y, width, height) {
        this.nativeObject.xtr_fillRect({ x: x, y: y, width: width, height: height });
    };
    CanvasView.prototype.strokeRect = function (x, y, width, height) {
        this.nativeObject.xtr_strokeRect({ x: x, y: y, width: width, height: height });
    };
    CanvasView.prototype.fill = function () {
        this.nativeObject.xtr_fill();
    };
    CanvasView.prototype.stroke = function () {
        this.nativeObject.xtr_stroke();
    };
    CanvasView.prototype.beginPath = function () {
        this.nativeObject.xtr_beginPath();
    };
    CanvasView.prototype.moveTo = function (x, y) {
        this.nativeObject.xtr_moveTo({ x: x, y: y });
    };
    CanvasView.prototype.closePath = function () {
        this.nativeObject.xtr_closePath();
    };
    CanvasView.prototype.lineTo = function (x, y) {
        this.nativeObject.xtr_lineTo({ x: x, y: y });
    };
    CanvasView.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        this.nativeObject.xtr_quadraticCurveTo({ x: cpx, y: cpy }, { x: x, y: y });
    };
    CanvasView.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        this.nativeObject.xtr_bezierCurveTo({ x: cp1x, y: cp1y }, { x: cp2x, y: cp2y }, { x: x, y: y });
    };
    CanvasView.prototype.arc = function (x, y, r, sAngle, eAngle, counterclockwise) {
        if (counterclockwise === void 0) { counterclockwise = false; }
        this.nativeObject.xtr_arc({ x: x, y: y }, r, sAngle, eAngle, counterclockwise);
    };
    CanvasView.prototype.postScale = function (x, y) {
        this.nativeObject.xtr_postScale({ x: x, y: y });
    };
    CanvasView.prototype.postRotate = function (angle) {
        this.nativeObject.xtr_postRotate(angle);
    };
    CanvasView.prototype.postTranslate = function (x, y) {
        this.nativeObject.xtr_postTranslate({ x: x, y: y });
    };
    CanvasView.prototype.postTransform = function (a, b, c, d, tx, ty) {
        this.nativeObject.xtr_postTransform({ a: a, b: b, c: c, d: d, tx: tx, ty: ty });
    };
    CanvasView.prototype.setTransform = function (a, b, c, d, tx, ty) {
        this.nativeObject.xtr_setCanvasTransform({ a: a, b: b, c: c, d: d, tx: tx, ty: ty });
    };
    CanvasView.prototype.save = function () {
        this.nativeObject.xtr_save();
    };
    CanvasView.prototype.restore = function () {
        this.nativeObject.xtr_restore();
    };
    CanvasView.prototype.isPointInPath = function (x, y) {
        return this.nativeObject.xtr_isPointInPath({ x: x, y: y });
    };
    CanvasView.prototype.clear = function () {
        this.nativeObject.xtr_clear();
    };
    return CanvasView;
}(View_1.View));
exports.CanvasView = CanvasView;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRCanvasView$InnerObject") === 0) {
        return new CanvasView(undefined, view);
    }
    return undefined;
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))

/***/ }),

/***/ 27:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(4);
var ImageRenderingMode;
(function (ImageRenderingMode) {
    ImageRenderingMode[ImageRenderingMode["Automatic"] = 0] = "Automatic";
    ImageRenderingMode[ImageRenderingMode["Original"] = 1] = "Original";
    ImageRenderingMode[ImageRenderingMode["Template"] = 2] = "Template";
})(ImageRenderingMode = exports.ImageRenderingMode || (exports.ImageRenderingMode = {}));
var Image = /** @class */ (function () {
    function Image() {
        this.renderingMode = ImageRenderingMode.Original;
    }
    Image.fromURL = function (url, success, failure) { };
    Image.fromAssets = function (named, success, failure) { };
    Image.fromAssetsWithScales = function (named, scales, success, failure) { };
    Image.fromBase64 = function (value, scale, success) { };
    Image.prototype.imageWithImageRenderingMode = function (renderingMode) {
        throw "TODO";
    };
    Image.assetsPath = "./assets/";
    return Image;
}());
exports.Image = Image;
var ContentMode;
(function (ContentMode) {
    ContentMode[ContentMode["ScaleToFill"] = 0] = "ScaleToFill";
    ContentMode[ContentMode["ScaleAspectFit"] = 1] = "ScaleAspectFit";
    ContentMode[ContentMode["ScaleAspectFill"] = 2] = "ScaleAspectFill";
})(ContentMode = exports.ContentMode || (exports.ContentMode = {}));
var ImageView = /** @class */ (function (_super) {
    __extends(ImageView, _super);
    function ImageView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.contentMode = ContentMode.ScaleToFill;
        return _this;
    }
    return ImageView;
}(View_1.View));
exports.ImageView = ImageView;


/***/ }),

/***/ 270:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var CustomView = /** @class */ (function (_super) {
    __extends(CustomView, _super);
    function CustomView(className, rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        _this.onMessage = undefined;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRCustomView.createScriptObject(className, rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            setImmediate(function () { _this.init(); });
        }
        return _this;
    }
    CustomView.prototype.emitMessage = function (message) {
        return this.nativeObject.handleMessage(message);
    };
    CustomView.prototype.handleMessage = function (message) {
        if (this.onMessage) {
            return this.onMessage(message);
        }
        return undefined;
    };
    return CustomView;
}(View_1.View));
exports.CustomView = CustomView;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.constructor.toString() === "com.opensource.xtruntime.XTRCustomView$InnerObject") {
        return new CustomView("", undefined, view);
    }
    return undefined;
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).setImmediate))

/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(18), __webpack_require__(22)))

/***/ }),

/***/ 35:
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/**
* AutoLayout.js is licensed under the MIT license. If a copy of the
* MIT-license was not distributed with this file, You can obtain one at:
* http://opensource.org/licenses/mit-license.html.
*
* @author: Hein Rutjes (IjzerenHein)
* @license MIT
* @copyright Gloey Apps, 2017
*
* @library autolayout.js
* @version 0.7.0
*/
/**
* Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
* Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
*
* Use of this source code is governed by the LGPL, which can be found in the
* COPYING.LGPL file.
*/
(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AutoLayout = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var c = require('cassowary/bin/c');
'use strict';

/**
 * Layout attributes.
 * @enum {String}
 */
var Attribute = {
  CONST: 'const',
  NOTANATTRIBUTE: 'const',
  VARIABLE: 'var',
  LEFT: 'left',
  RIGHT: 'right',
  TOP: 'top',
  BOTTOM: 'bottom',
  WIDTH: 'width',
  HEIGHT: 'height',
  CENTERX: 'centerX',
  CENTERY: 'centerY',
  /*LEADING: 'leading',
  TRAILING: 'trailing'*/
  /** Used by the extended VFL syntax. */
  ZINDEX: 'zIndex'
};

/**
 * Relation types.
 * @enum {String}
 */
var Relation = {
  /** Less than or equal */
  LEQ: 'leq',
  /** Equal */
  EQU: 'equ',
  /** Greater than or equal */
  GEQ: 'geq'
};

/**
 * Layout priorities.
 * @enum {String}
 */
var Priority = {
  REQUIRED: 1000,
  DEFAULTHIGH: 750,
  DEFAULTLOW: 250
  //FITTINGSIZELEVEL: 50,
};

var parser = function () {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.offset = offset;
    this.line = line;
    this.column = column;

    this.name = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { visualFormatString: peg$parsevisualFormatString },
        peg$startRuleFunction = peg$parsevisualFormatString,
        peg$c0 = peg$FAILED,
        peg$c1 = null,
        peg$c2 = ":",
        peg$c3 = { type: "literal", value: ":", description: "\":\"" },
        peg$c4 = [],
        peg$c5 = function peg$c5(o, superto, view, views, tosuper) {
      return {
        orientation: o ? o[0] : 'horizontal',
        cascade: (superto || []).concat([view], [].concat.apply([], views), tosuper || [])
      };
    },
        peg$c6 = "H",
        peg$c7 = { type: "literal", value: "H", description: "\"H\"" },
        peg$c8 = "V",
        peg$c9 = { type: "literal", value: "V", description: "\"V\"" },
        peg$c10 = function peg$c10(orient) {
      return orient == 'H' ? 'horizontal' : 'vertical';
    },
        peg$c11 = "|",
        peg$c12 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c13 = function peg$c13() {
      return { view: null };
    },
        peg$c14 = "[",
        peg$c15 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c16 = "]",
        peg$c17 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c18 = function peg$c18(view, predicates) {
      return extend(view, predicates ? { constraints: predicates } : {});
    },
        peg$c19 = "-",
        peg$c20 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c21 = function peg$c21(predicateList) {
      return predicateList;
    },
        peg$c22 = function peg$c22() {
      return [{ relation: 'equ', constant: 'default', $parserOffset: offset() }];
    },
        peg$c23 = "",
        peg$c24 = function peg$c24() {
      return [{ relation: 'equ', constant: 0, $parserOffset: offset() }];
    },
        peg$c25 = function peg$c25(n) {
      return [{ relation: 'equ', constant: n, $parserOffset: offset() }];
    },
        peg$c26 = "(",
        peg$c27 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c28 = ",",
        peg$c29 = { type: "literal", value: ",", description: "\",\"" },
        peg$c30 = ")",
        peg$c31 = { type: "literal", value: ")", description: "\")\"" },
        peg$c32 = function peg$c32(p, ps) {
      return [p].concat(ps.map(function (p) {
        return p[1];
      }));
    },
        peg$c33 = "@",
        peg$c34 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c35 = function peg$c35(r, o, p) {
      return extend({ relation: 'equ' }, r || {}, o, p ? p[1] : {});
    },
        peg$c36 = "==",
        peg$c37 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c38 = function peg$c38() {
      return { relation: 'equ', $parserOffset: offset() };
    },
        peg$c39 = "<=",
        peg$c40 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c41 = function peg$c41() {
      return { relation: 'leq', $parserOffset: offset() };
    },
        peg$c42 = ">=",
        peg$c43 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c44 = function peg$c44() {
      return { relation: 'geq', $parserOffset: offset() };
    },
        peg$c45 = /^[0-9]/,
        peg$c46 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c47 = function peg$c47(digits) {
      return { priority: parseInt(digits.join(""), 10) };
    },
        peg$c48 = function peg$c48(n) {
      return { constant: n };
    },
        peg$c49 = /^[a-zA-Z_]/,
        peg$c50 = { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" },
        peg$c51 = /^[a-zA-Z0-9_]/,
        peg$c52 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" },
        peg$c53 = function peg$c53(f, v) {
      return { view: f + v };
    },
        peg$c54 = ".",
        peg$c55 = { type: "literal", value: ".", description: "\".\"" },
        peg$c56 = function peg$c56(digits, decimals) {
      return parseFloat(digits.concat(".").concat(decimals).join(""), 10);
    },
        peg$c57 = function peg$c57(digits) {
      return parseInt(digits.join(""), 10);
    },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function (a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }

          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
            return '\\x' + hex(ch);
          }).replace(/[\u0180-\u0FFF]/g, function (ch) {
            return '\\u0' + hex(ch);
          }).replace(/[\u1080-\uFFFF]/g, function (ch) {
            return '\\u' + hex(ch);
          });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
    }

    function peg$parsevisualFormatString() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseorientation();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c2;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c3);
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parsesuperview();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseconnection();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseview();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parseconnection();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseview();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parseconnection();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseview();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseconnection();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesuperview();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c5(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseorientation() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 72) {
        s1 = peg$c6;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c7);
        }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 86) {
          s1 = peg$c8;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c9);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c10(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsesuperview() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c11;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c12);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c13();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseview() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c14;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c15);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseviewName();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsepredicateListWithParens();
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c16;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c18(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseconnection() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c19;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c20);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepredicateList();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 45) {
            s3 = peg$c19;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c20);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c19;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c20);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$c23;
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsepredicateList() {
      var s0;

      s0 = peg$parsesimplePredicate();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepredicateListWithParens();
      }

      return s0;
    }

    function peg$parsesimplePredicate() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c25(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsepredicateListWithParens() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c26;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c27);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepredicate();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c28;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c29);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parsepredicate();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c28;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c29);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsepredicate();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c30;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c31);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c32(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsepredicate() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parserelation();
      if (s1 === peg$FAILED) {
        s1 = peg$c1;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseobjectOfPredicate();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s4 = peg$c33;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c34);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepriority();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c1;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c35(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parserelation() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c36) {
        s1 = peg$c36;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c37);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c38();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c39) {
          s1 = peg$c39;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c40);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c41();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c42) {
            s1 = peg$c42;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c44();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseobjectOfPredicate() {
      var s0;

      s0 = peg$parseconstant();
      if (s0 === peg$FAILED) {
        s0 = peg$parseviewName();
      }

      return s0;
    }

    function peg$parsepriority() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c46);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c47(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseconstant() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c48(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseviewName() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      if (peg$c49.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c50);
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c49.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
        }
      } else {
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s2 = input.substring(s1, peg$currPos);
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c51.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c52);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c51.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c52);
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c45.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c46);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c54;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c55);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c45.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c46);
            }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c45.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c46);
                }
              }
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c56(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (peg$c45.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c46);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c45.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c46);
              }
            }
          }
        } else {
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c57(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function extend(dst) {
      for (var i = 1; i < arguments.length; i++) {
        for (var k in arguments[i]) {
          dst[k] = arguments[i][k];
        }
      }
      return dst;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse: parse
  };
}();

var parserExt = function () {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.offset = offset;
    this.line = line;
    this.column = column;

    this.name = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},
        peg$FAILED = {},
        peg$startRuleFunctions = { visualFormatStringExt: peg$parsevisualFormatStringExt },
        peg$startRuleFunction = peg$parsevisualFormatStringExt,
        peg$c0 = peg$FAILED,
        peg$c1 = "C:",
        peg$c2 = { type: "literal", value: "C:", description: "\"C:\"" },
        peg$c3 = [],
        peg$c4 = null,
        peg$c5 = function peg$c5(view, attribute, attributes, comments) {
      return {
        type: 'attribute',
        view: view.view,
        attributes: [attribute].concat(attributes)
      };
    },
        peg$c6 = function peg$c6(attr, predicates) {
      return { attr: attr, predicates: predicates };
    },
        peg$c7 = ":",
        peg$c8 = { type: "literal", value: ":", description: "\":\"" },
        peg$c9 = function peg$c9(o, superto, view, views, tosuper, comments) {
      return {
        type: 'vfl',
        orientation: o ? o[0] : 'horizontal',
        cascade: (superto || []).concat(view, [].concat.apply([], views), tosuper || [])
      };
    },
        peg$c10 = "HV",
        peg$c11 = { type: "literal", value: "HV", description: "\"HV\"" },
        peg$c12 = function peg$c12() {
      return 'horzvert';
    },
        peg$c13 = "H",
        peg$c14 = { type: "literal", value: "H", description: "\"H\"" },
        peg$c15 = function peg$c15() {
      return 'horizontal';
    },
        peg$c16 = "V",
        peg$c17 = { type: "literal", value: "V", description: "\"V\"" },
        peg$c18 = function peg$c18() {
      return 'vertical';
    },
        peg$c19 = "Z",
        peg$c20 = { type: "literal", value: "Z", description: "\"Z\"" },
        peg$c21 = function peg$c21() {
      return 'zIndex';
    },
        peg$c22 = " ",
        peg$c23 = { type: "literal", value: " ", description: "\" \"" },
        peg$c24 = "//",
        peg$c25 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c26 = { type: "any", description: "any character" },
        peg$c27 = "|",
        peg$c28 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c29 = function peg$c29() {
      return { view: null };
    },
        peg$c30 = "[",
        peg$c31 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c32 = ",",
        peg$c33 = { type: "literal", value: ",", description: "\",\"" },
        peg$c34 = "]",
        peg$c35 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c36 = function peg$c36(view, views) {
      return views.length ? [view].concat([].concat.apply([], views)) : view;
    },
        peg$c37 = function peg$c37(view, predicates, cascadedViews) {
      return extend(extend(view, predicates ? { constraints: predicates } : {}), cascadedViews ? {
        cascade: cascadedViews
      } : {});
    },
        peg$c38 = function peg$c38(views, connection) {
      return [].concat([].concat.apply([], views), [connection]);
    },
        peg$c39 = "->",
        peg$c40 = { type: "literal", value: "->", description: "\"->\"" },
        peg$c41 = function peg$c41() {
      return [{ relation: 'none' }];
    },
        peg$c42 = "-",
        peg$c43 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c44 = function peg$c44(predicateList) {
      return predicateList;
    },
        peg$c45 = function peg$c45() {
      return [{ relation: 'equ', constant: 'default' }];
    },
        peg$c46 = "~",
        peg$c47 = { type: "literal", value: "~", description: "\"~\"" },
        peg$c48 = function peg$c48() {
      return [{ relation: 'equ', equalSpacing: true }];
    },
        peg$c49 = "",
        peg$c50 = function peg$c50() {
      return [{ relation: 'equ', constant: 0 }];
    },
        peg$c51 = function peg$c51(p) {
      return [{ relation: 'equ', multiplier: p.multiplier }];
    },
        peg$c52 = function peg$c52(n) {
      return [{ relation: 'equ', constant: n }];
    },
        peg$c53 = "(",
        peg$c54 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c55 = ")",
        peg$c56 = { type: "literal", value: ")", description: "\")\"" },
        peg$c57 = function peg$c57(p, ps) {
      return [p].concat(ps.map(function (p) {
        return p[1];
      }));
    },
        peg$c58 = "@",
        peg$c59 = { type: "literal", value: "@", description: "\"@\"" },
        peg$c60 = function peg$c60(r, o, p) {
      return extend({ relation: 'equ' }, r || {}, o, p ? p[1] : {});
    },
        peg$c61 = function peg$c61(r, o, p) {
      return extend({ relation: 'equ', equalSpacing: true }, r || {}, o, p ? p[1] : {});
    },
        peg$c62 = "==",
        peg$c63 = { type: "literal", value: "==", description: "\"==\"" },
        peg$c64 = function peg$c64() {
      return { relation: 'equ' };
    },
        peg$c65 = "<=",
        peg$c66 = { type: "literal", value: "<=", description: "\"<=\"" },
        peg$c67 = function peg$c67() {
      return { relation: 'leq' };
    },
        peg$c68 = ">=",
        peg$c69 = { type: "literal", value: ">=", description: "\">=\"" },
        peg$c70 = function peg$c70() {
      return { relation: 'geq' };
    },
        peg$c71 = /^[0-9]/,
        peg$c72 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c73 = function peg$c73(digits) {
      return { priority: parseInt(digits.join(""), 10) };
    },
        peg$c74 = function peg$c74(n) {
      return { constant: n };
    },
        peg$c75 = function peg$c75(n) {
      return { constant: -n };
    },
        peg$c76 = "+",
        peg$c77 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c78 = "%",
        peg$c79 = { type: "literal", value: "%", description: "\"%\"" },
        peg$c80 = function peg$c80(n) {
      return { view: null, multiplier: n / 100 };
    },
        peg$c81 = function peg$c81(n) {
      return { view: null, multiplier: n / -100 };
    },
        peg$c82 = function peg$c82(vn, a, m, c) {
      return { view: vn.view, attribute: a ? a : undefined, multiplier: m ? m : 1, constant: c ? c : undefined };
    },
        peg$c83 = ".left",
        peg$c84 = { type: "literal", value: ".left", description: "\".left\"" },
        peg$c85 = function peg$c85() {
      return 'left';
    },
        peg$c86 = ".right",
        peg$c87 = { type: "literal", value: ".right", description: "\".right\"" },
        peg$c88 = function peg$c88() {
      return 'right';
    },
        peg$c89 = ".top",
        peg$c90 = { type: "literal", value: ".top", description: "\".top\"" },
        peg$c91 = function peg$c91() {
      return 'top';
    },
        peg$c92 = ".bottom",
        peg$c93 = { type: "literal", value: ".bottom", description: "\".bottom\"" },
        peg$c94 = function peg$c94() {
      return 'bottom';
    },
        peg$c95 = ".width",
        peg$c96 = { type: "literal", value: ".width", description: "\".width\"" },
        peg$c97 = function peg$c97() {
      return 'width';
    },
        peg$c98 = ".height",
        peg$c99 = { type: "literal", value: ".height", description: "\".height\"" },
        peg$c100 = function peg$c100() {
      return 'height';
    },
        peg$c101 = ".centerX",
        peg$c102 = { type: "literal", value: ".centerX", description: "\".centerX\"" },
        peg$c103 = function peg$c103() {
      return 'centerX';
    },
        peg$c104 = ".centerY",
        peg$c105 = { type: "literal", value: ".centerY", description: "\".centerY\"" },
        peg$c106 = function peg$c106() {
      return 'centerY';
    },
        peg$c107 = "/",
        peg$c108 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c109 = function peg$c109(n) {
      return 1 / n;
    },
        peg$c110 = "/+",
        peg$c111 = { type: "literal", value: "/+", description: "\"/+\"" },
        peg$c112 = "/-",
        peg$c113 = { type: "literal", value: "/-", description: "\"/-\"" },
        peg$c114 = function peg$c114(n) {
      return -1 / n;
    },
        peg$c115 = "*",
        peg$c116 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c117 = function peg$c117(n) {
      return n;
    },
        peg$c118 = "*+",
        peg$c119 = { type: "literal", value: "*+", description: "\"*+\"" },
        peg$c120 = "*-",
        peg$c121 = { type: "literal", value: "*-", description: "\"*-\"" },
        peg$c122 = function peg$c122(n) {
      return -n;
    },
        peg$c123 = /^[a-zA-Z_]/,
        peg$c124 = { type: "class", value: "[a-zA-Z_]", description: "[a-zA-Z_]" },
        peg$c125 = /^[a-zA-Z0-9_]/,
        peg$c126 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" },
        peg$c127 = function peg$c127(f, v, r) {
      return { view: f + v, range: r, $parserOffset: offset() };
    },
        peg$c128 = function peg$c128(f, v) {
      return { view: f + v, $parserOffset: offset() };
    },
        peg$c129 = "..",
        peg$c130 = { type: "literal", value: "..", description: "\"..\"" },
        peg$c131 = function peg$c131(d) {
      return parseInt(d);
    },
        peg$c132 = ".",
        peg$c133 = { type: "literal", value: ".", description: "\".\"" },
        peg$c134 = function peg$c134(digits, decimals) {
      return parseFloat(digits.concat(".").concat(decimals).join(""), 10);
    },
        peg$c135 = function peg$c135(digits) {
      return parseInt(digits.join(""), 10);
    },
        peg$currPos = 0,
        peg$reportedPos = 0,
        peg$cachedPos = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos = 0,
        peg$maxFailExpected = [],
        peg$silentFails = 0,
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) {
              details.line++;
            }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === '\u2028' || ch === '\u2029') {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function (a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
          }

          return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
            return '\\x0' + hex(ch);
          }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
            return '\\x' + hex(ch);
          }).replace(/[\u0180-\u0FFF]/g, function (ch) {
            return '\\u0' + hex(ch);
          }).replace(/[\u1080-\uFFFF]/g, function (ch) {
            return '\\u' + hex(ch);
          });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc,
            foundDesc,
            i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
    }

    function peg$parsevisualFormatStringExt() {
      var s0;

      s0 = peg$parsevisualFormatString();
      if (s0 === peg$FAILED) {
        s0 = peg$parsevisualFormatStringConstraintExpression();
      }

      return s0;
    }

    function peg$parsevisualFormatStringConstraintExpression() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c1) {
        s1 = peg$c1;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c2);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseviewName();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseattributePredicate();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$parseattributePredicate();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseattributePredicate();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsecomments();
              if (s5 === peg$FAILED) {
                s5 = peg$c4;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c5(s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseattributePredicate() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseattribute();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepredicateListWithParens();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsevisualFormatString() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseorientation();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c7;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c8);
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parsesuperview();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseconnection();
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseviewGroup();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parseconnection();
            if (s6 !== peg$FAILED) {
              s7 = peg$parseviewGroup();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$c0;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parseconnection();
              if (s6 !== peg$FAILED) {
                s7 = peg$parseviewGroup();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parseconnection();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsesuperview();
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$c0;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$c0;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c4;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsecomments();
                if (s6 === peg$FAILED) {
                  s6 = peg$c4;
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c9(s1, s2, s3, s4, s5, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseorientation() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c10) {
        s1 = peg$c10;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c11);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c12();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 72) {
          s1 = peg$c13;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c14);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c15();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 86) {
            s1 = peg$c16;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c17);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c18();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 90) {
              s1 = peg$c19;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c20);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c21();
            }
            s0 = s1;
          }
        }
      }

      return s0;
    }

    function peg$parsecomments() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (input.charCodeAt(peg$currPos) === 32) {
        s2 = peg$c22;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c23);
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c22;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c23);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c24) {
          s2 = peg$c24;
          peg$currPos += 2;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c25);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.length > peg$currPos) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c26);
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesuperview() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c27;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c28);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c29();
      }
      s0 = s1;

      return s0;
    }

    function peg$parseviewGroup() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c30;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c31);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseview();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c32;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseview();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c32;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c33);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseview();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c34;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c36(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseview() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseviewNameRange();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepredicateListWithParens();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsecascadedViews();
          if (s3 === peg$FAILED) {
            s3 = peg$c4;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c37(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsecascadedViews() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c7;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c8);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseconnection();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseviewGroup();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseconnection();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseviewGroup();
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseconnection();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c38(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseconnection() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c39) {
        s1 = peg$c39;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c40);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c42;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsepredicateList();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s3 = peg$c42;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c43);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c44(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c42;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c45();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 126) {
              s1 = peg$c46;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c47);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseequalSpacingPredicateList();
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 126) {
                  s3 = peg$c46;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c47);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c44(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 126) {
                s1 = peg$c46;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c47);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c48();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$c49;
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c50();
                }
                s0 = s1;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsepredicateList() {
      var s0;

      s0 = peg$parsesimplePredicate();
      if (s0 === peg$FAILED) {
        s0 = peg$parsepredicateListWithParens();
      }

      return s0;
    }

    function peg$parsesimplePredicate() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsepercentage();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c51(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsenumber();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c52(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsepredicateListWithParens() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c53;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c54);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepredicate();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c32;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parsepredicate();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c32;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c33);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsepredicate();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c55;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c56);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsepredicate() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parserelation();
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseobjectOfPredicate();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s4 = peg$c58;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c59);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepriority();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c4;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c60(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseequalSpacingPredicateList() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c53;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c54);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseequalSpacingPredicate();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c32;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseequalSpacingPredicate();
            if (s6 !== peg$FAILED) {
              s5 = [s5, s6];
              s4 = s5;
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c32;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c33);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseequalSpacingPredicate();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c0;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c0;
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c55;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c56);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c57(s2, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseequalSpacingPredicate() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parserelation();
      if (s1 === peg$FAILED) {
        s1 = peg$c4;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseobjectOfPredicate();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s4 = peg$c58;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c59);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsepriority();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$c4;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c61(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parserelation() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c62) {
        s1 = peg$c62;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c63);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c64();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c65) {
          s1 = peg$c65;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c67();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c68) {
            s1 = peg$c68;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c69);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c70();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parseobjectOfPredicate() {
      var s0;

      s0 = peg$parsepercentage();
      if (s0 === peg$FAILED) {
        s0 = peg$parseconstant();
        if (s0 === peg$FAILED) {
          s0 = peg$parseviewPredicate();
        }
      }

      return s0;
    }

    function peg$parsepriority() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c71.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c71.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c73(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseconstant() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c74(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c42;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsenumber();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c75(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c76;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parsepercentage() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 37) {
          s2 = peg$c78;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c79);
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c80(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s1 = peg$c42;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsenumber();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 37) {
              s3 = peg$c78;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c79);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c81(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 43) {
            s1 = peg$c76;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 37) {
                s3 = peg$c78;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c79);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c80(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      return s0;
    }

    function peg$parseviewPredicate() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseviewName();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseattribute();
        if (s2 === peg$FAILED) {
          s2 = peg$c4;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemultiplier();
          if (s3 === peg$FAILED) {
            s3 = peg$c4;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseconstantExpr();
            if (s4 === peg$FAILED) {
              s4 = peg$c4;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c82(s1, s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseattribute() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c83) {
        s1 = peg$c83;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c84);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c85();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c86) {
          s1 = peg$c86;
          peg$currPos += 6;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c87);
          }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c88();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 4) === peg$c89) {
            s1 = peg$c89;
            peg$currPos += 4;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c90);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c91();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7) === peg$c92) {
              s1 = peg$c92;
              peg$currPos += 7;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c93);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c94();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 6) === peg$c95) {
                s1 = peg$c95;
                peg$currPos += 6;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c96);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c97();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 7) === peg$c98) {
                  s1 = peg$c98;
                  peg$currPos += 7;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c99);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c100();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 8) === peg$c101) {
                    s1 = peg$c101;
                    peg$currPos += 8;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c102);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c103();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 8) === peg$c104) {
                      s1 = peg$c104;
                      peg$currPos += 8;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c105);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c106();
                    }
                    s0 = s1;
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsemultiplier() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c107;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c108);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c109(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c110) {
          s1 = peg$c110;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c111);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsenumber();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c109(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c112) {
            s1 = peg$c112;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c113);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c114(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 42) {
              s1 = peg$c115;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c116);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsenumber();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c117(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c118) {
                s1 = peg$c118;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c119);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsenumber();
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c117(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c120) {
                  s1 = peg$c120;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c121);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsenumber();
                  if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c122(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseconstantExpr() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c42;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c43);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c122(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c76;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c77);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsenumber();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c117(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseviewNameRange() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      if (peg$c123.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c124);
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c123.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
        }
      } else {
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s2 = input.substring(s1, peg$currPos);
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c125.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c125.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parserange();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c127(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        if (peg$c123.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c124);
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c123.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c124);
              }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s2 = input.substring(s1, peg$currPos);
        }
        s1 = s2;
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = [];
          if (peg$c125.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c125.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c126);
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s3 = input.substring(s2, peg$currPos);
          }
          s2 = s3;
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c128(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      return s0;
    }

    function peg$parseviewName() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      if (peg$c123.test(input.charAt(peg$currPos))) {
        s3 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c124);
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          if (peg$c123.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c124);
            }
          }
        }
      } else {
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s2 = input.substring(s1, peg$currPos);
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = [];
        if (peg$c125.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c126);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c125.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c128(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parserange() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c129) {
        s1 = peg$c129;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c130);
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        if (peg$c71.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$c71.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c72);
              }
            }
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c131(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c71.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c71.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
        }
      } else {
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c132;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c133);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c71.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c72);
            }
          }
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c71.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c72);
                }
              }
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c134(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (peg$c71.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c72);
          }
        }
        if (s2 !== peg$FAILED) {
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$c71.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c72);
              }
            }
          }
        } else {
          s1 = peg$c0;
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c135(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function extend(dst) {
      for (var i = 1; i < arguments.length; i++) {
        for (var k in arguments[i]) {
          dst[k] = arguments[i][k];
        }
      }
      return dst;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse: parse
  };
}();

var Orientation = {
  HORIZONTAL: 1,
  VERTICAL: 2,
  ZINDEX: 4
};

/**
 * Helper function that inserts equal spacers (~).
 * @private
 */
function _processEqualSpacer(context, stackView) {

  // Determine unique name for the spacer
  context.equalSpacerIndex = context.equalSpacerIndex || 1;
  var name = '_~' + context.lineIndex + ':' + context.equalSpacerIndex + '~';
  if (context.equalSpacerIndex > 1) {

    // Ensure that all spacers have the same width/height
    context.constraints.push({
      view1: '_~' + context.lineIndex + ':1~',
      attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
      relation: context.relation.relation || Relation.EQU,
      view2: name,
      attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
      priority: context.relation.priority
    });
  }
  context.equalSpacerIndex++;

  // Enforce view/proportional width/height
  if (context.relation.view || context.relation.multiplier && context.relation.multiplier !== 1) {
    context.constraints.push({
      view1: name,
      attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
      relation: context.relation.relation || Relation.EQU,
      view2: context.relation.view,
      attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
      priority: context.relation.priority,
      multiplier: context.relation.multiplier
    });
    context.relation.multiplier = undefined;
  } else if (context.relation.constant) {
    context.constraints.push({
      view1: name,
      attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
      relation: Relation.EQU,
      view2: null,
      attr2: Attribute.CONST,
      priority: context.relation.priority,
      constant: context.relation.constant
    });
    context.relation.constant = undefined;
  }

  // Add constraint
  for (var i = 0; i < context.prevViews.length; i++) {
    var prevView = context.prevViews[i];
    switch (context.orientation) {
      case Orientation.HORIZONTAL:
        context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
        context.curAttr = Attribute.LEFT;
        break;
      case Orientation.VERTICAL:
        context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
        context.curAttr = Attribute.TOP;
        break;
      case Orientation.ZINDEX:
        context.prevAttr = Attribute.ZINDEX;
        context.curAttr = Attribute.ZINDEX;
        context.relation.constant = prevView !== stackView ? 'default' : 0;
        break;
    }
    context.constraints.push({
      view1: prevView,
      attr1: context.prevAttr,
      relation: context.relation.relation,
      view2: name,
      attr2: context.curAttr,
      priority: context.relation.priority
    });
  }
  context.prevViews = [name];
}

/**
 * Helper function that inserts proportional spacers (-12%-).
 * @private
 */
function _processProportionalSpacer(context, stackView) {
  context.proportionalSpacerIndex = context.proportionalSpacerIndex || 1;
  var name = '_-' + context.lineIndex + ':' + context.proportionalSpacerIndex + '-';
  context.proportionalSpacerIndex++;
  context.constraints.push({
    view1: name,
    attr1: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
    relation: context.relation.relation || Relation.EQU,
    view2: context.relation.view, // or relative to the stackView... food for thought
    attr2: context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT,
    priority: context.relation.priority,
    multiplier: context.relation.multiplier
  });
  context.relation.multiplier = undefined;

  // Add constraint
  for (var i = 0; i < context.prevViews.length; i++) {
    var prevView = context.prevViews[i];
    switch (context.orientation) {
      case Orientation.HORIZONTAL:
        context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
        context.curAttr = Attribute.LEFT;
        break;
      case Orientation.VERTICAL:
        context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
        context.curAttr = Attribute.TOP;
        break;
      case Orientation.ZINDEX:
        context.prevAttr = Attribute.ZINDEX;
        context.curAttr = Attribute.ZINDEX;
        context.relation.constant = prevView !== stackView ? 'default' : 0;
        break;
    }
    context.constraints.push({
      view1: prevView,
      attr1: context.prevAttr,
      relation: context.relation.relation,
      view2: name,
      attr2: context.curAttr,
      priority: context.relation.priority
    });
  }
  context.prevViews = [name];
}

/**
 * In case of a stack-view, set constraints for opposite orientations
 * @private
 */
function _processStackView(context, name, subView) {
  var viewName = void 0;
  for (var orientation = 1; orientation <= 4; orientation *= 2) {
    if (subView.orientations & orientation && subView.stack.orientation !== orientation && !(subView.stack.processedOrientations & orientation)) {
      subView.stack.processedOrientations = subView.stack.processedOrientations | orientation;
      viewName = viewName || {
        name: name,
        type: 'stack'
      };
      for (var i = 0, j = subView.stack.subViews.length; i < j; i++) {
        if (orientation === Orientation.ZINDEX) {
          context.constraints.push({
            view1: viewName,
            attr1: Attribute.ZINDEX,
            relation: Relation.EQU,
            view2: subView.stack.subViews[i],
            attr2: Attribute.ZINDEX
          });
        } else {
          context.constraints.push({
            view1: viewName,
            attr1: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH,
            relation: Relation.EQU,
            view2: subView.stack.subViews[i],
            attr2: orientation === Orientation.VERTICAL ? Attribute.HEIGHT : Attribute.WIDTH
          });
          context.constraints.push({
            view1: viewName,
            attr1: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT,
            relation: Relation.EQU,
            view2: subView.stack.subViews[i],
            attr2: orientation === Orientation.VERTICAL ? Attribute.TOP : Attribute.LEFT
          });
        }
      }
    }
  }
}

/**
 * Recursive helper function converts a view-name and a range to a series
 * of view-names (e.g. [child1, child2, child3, ...]).
 * @private
 */
function _getRange(name, range) {
  if (range === true) {
    range = name.match(/\.\.\d+$/);
    if (range) {
      name = name.substring(0, name.length - range[0].length);
      range = parseInt(range[0].substring(2));
    }
  }
  if (!range) {
    return [name];
  }
  var start = name.match(/\d+$/);
  var res = [];
  var i;
  if (start) {
    name = name.substring(0, name.length - start[0].length);
    for (i = parseInt(start); i <= range; i++) {
      res.push(name + i);
    }
  } else {
    res.push(name);
    for (i = 2; i <= range; i++) {
      res.push(name + i);
    }
  }
  return res;
}

/**
 * Recursive helper function that processes the cascaded data.
 * @private
 */
function _processCascade(context, cascade, parentItem) {
  var stackView = parentItem ? parentItem.view : null;
  var subViews = [];
  var curViews = [];
  var subView = void 0;
  if (stackView) {
    cascade.push({ view: stackView });
    curViews.push(stackView);
  }
  for (var i = 0; i < cascade.length; i++) {
    var item = cascade[i];
    if (!Array.isArray(item) && item.hasOwnProperty('view') || Array.isArray(item) && item[0].view && !item[0].relation) {
      var items = Array.isArray(item) ? item : [item];
      for (var z = 0; z < items.length; z++) {
        item = items[z];
        var viewRange = item === ',' ? [] : item.view ? _getRange(item.view, item.range) : [null];
        for (var r = 0; r < viewRange.length; r++) {
          var curView = viewRange[r];
          curViews.push(curView);

          //
          // Add this view to the collection of subViews
          //
          if (curView !== stackView) {
            subViews.push(curView);
            subView = context.subViews[curView];
            if (!subView) {
              subView = { orientations: 0 };
              context.subViews[curView] = subView;
            }
            subView.orientations = subView.orientations | context.orientation;
            if (subView.stack) {
              _processStackView(context, curView, subView);
            }
          }

          //
          // Process the relationship between this and the previous views
          //
          if (context.prevViews !== undefined && curView !== undefined && context.relation) {
            if (context.relation.relation !== 'none') {
              for (var p = 0; p < context.prevViews.length; p++) {
                var prevView = context.prevViews[p];
                switch (context.orientation) {
                  case Orientation.HORIZONTAL:
                    context.prevAttr = prevView !== stackView ? Attribute.RIGHT : Attribute.LEFT;
                    context.curAttr = curView !== stackView ? Attribute.LEFT : Attribute.RIGHT;
                    break;
                  case Orientation.VERTICAL:
                    context.prevAttr = prevView !== stackView ? Attribute.BOTTOM : Attribute.TOP;
                    context.curAttr = curView !== stackView ? Attribute.TOP : Attribute.BOTTOM;
                    break;
                  case Orientation.ZINDEX:
                    context.prevAttr = Attribute.ZINDEX;
                    context.curAttr = Attribute.ZINDEX;
                    context.relation.constant = !prevView ? 0 : context.relation.constant || 'default';
                    break;
                }
                context.constraints.push({
                  view1: prevView,
                  attr1: context.prevAttr,
                  relation: context.relation.relation,
                  view2: curView,
                  attr2: context.curAttr,
                  multiplier: context.relation.multiplier,
                  constant: context.relation.constant === 'default' || !context.relation.constant ? context.relation.constant : -context.relation.constant,
                  priority: context.relation.priority
                });
              }
            }
          }

          //
          // Process view size constraints
          //
          var constraints = item.constraints;
          if (constraints) {
            for (var n = 0; n < constraints.length; n++) {
              context.prevAttr = context.horizontal ? Attribute.WIDTH : Attribute.HEIGHT;
              context.curAttr = constraints[n].view || constraints[n].multiplier ? constraints[n].attribute || context.prevAttr : constraints[n].variable ? Attribute.VARIABLE : Attribute.CONST;
              context.constraints.push({
                view1: curView,
                attr1: context.prevAttr,
                relation: constraints[n].relation,
                view2: constraints[n].view,
                attr2: context.curAttr,
                multiplier: constraints[n].multiplier,
                constant: constraints[n].constant,
                priority: constraints[n].priority
              });
            }
          }

          //
          // Process cascaded data (child stack-views)
          //
          if (item.cascade) {
            _processCascade(context, item.cascade, item);
          }
        }
      }
    } else if (item !== ',') {
      context.prevViews = curViews;
      curViews = [];
      context.relation = item[0];
      if (context.prevViews !== undefined) {
        if (context.relation.equalSpacing) {
          _processEqualSpacer(context, stackView);
        }
        if (context.relation.multiplier) {
          _processProportionalSpacer(context, stackView);
        }
      }
    }
  }

  if (stackView) {
    subView = context.subViews[stackView];
    if (!subView) {
      subView = { orientations: context.orientation };
      context.subViews[stackView] = subView;
    } else if (subView.stack) {
      var err = new Error('A stack named "' + stackView + '" has already been created');
      err.column = parentItem.$parserOffset + 1;
      throw err;
    }
    subView.stack = {
      orientation: context.orientation,
      processedOrientations: context.orientation,
      subViews: subViews
    };
    _processStackView(context, stackView, subView);
  }
}

var metaInfoCategories = ['viewport', 'spacing', 'colors', 'shapes', 'widths', 'heights'];

/**
 * VisualFormat
 *
 * @namespace VisualFormat
 */

var VisualFormat = function () {
  function VisualFormat() {
    _classCallCheck(this, VisualFormat);
  }

  _createClass(VisualFormat, null, [{
    key: 'parseLine',


    /**
     * Parses a single line of vfl into an array of constraint definitions.
     *
     * When the visual-format could not be succesfully parsed an exception is thrown containing
     * additional info about the parse error and column position.
     *
     * @param {String} visualFormat Visual format string (cannot contain line-endings!).
     * @param {Object} [options] Configuration options.
     * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
     * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
     * @param {Number} [options.lineIndex] Line-index used when auto generating equal-spacing constraints.
     * @return {Array} Array of constraint definitions.
     */
    value: function parseLine(visualFormat, options) {
      if (visualFormat.length === 0 || options && options.extended && visualFormat.indexOf('//') === 0) {
        return [];
      }
      var res = options && options.extended ? parserExt.parse(visualFormat) : parser.parse(visualFormat);
      if (options && options.outFormat === 'raw') {
        return [res];
      }
      var context = {
        constraints: [],
        lineIndex: (options ? options.lineIndex : undefined) || 1,
        subViews: (options ? options.subViews : undefined) || {}
      };
      if (res.type === 'attribute') {
        for (var n = 0; n < res.attributes.length; n++) {
          var attr = res.attributes[n];
          for (var m = 0; m < attr.predicates.length; m++) {
            var predicate = attr.predicates[m];
            context.constraints.push({
              view1: res.view,
              attr1: attr.attr,
              relation: predicate.relation,
              view2: predicate.view,
              attr2: predicate.attribute || attr.attr,
              multiplier: predicate.multiplier,
              constant: predicate.constant,
              priority: predicate.priority
            });
          }
        }
      } else {
        switch (res.orientation) {
          case 'horizontal':
            context.orientation = Orientation.HORIZONTAL;
            context.horizontal = true;
            _processCascade(context, res.cascade, null);
            break;
          case 'vertical':
            context.orientation = Orientation.VERTICAL;
            _processCascade(context, res.cascade, null);
            break;
          case 'horzvert':
            context.orientation = Orientation.HORIZONTAL;
            context.horizontal = true;
            _processCascade(context, res.cascade, null);
            context = {
              constraints: context.constraints,
              lineIndex: context.lineIndex,
              subViews: context.subViews,
              orientation: Orientation.VERTICAL
            };
            _processCascade(context, res.cascade, null);
            break;
          case 'zIndex':
            context.orientation = Orientation.ZINDEX;
            _processCascade(context, res.cascade, null);
            break;
        }
      }
      return context.constraints;
    }

    /**
     * Parses one or more visual format strings into an array of constraint definitions.
     *
     * When the visual-format could not be succesfully parsed an exception is thrown containing
     * additional info about the parse error and column position.
     *
     * @param {String|Array} visualFormat One or more visual format strings.
     * @param {Object} [options] Configuration options.
     * @param {Boolean} [options.extended] When set to true uses the extended syntax (default: false).
     * @param {Boolean} [options.strict] When set to false trims any leading/trailing spaces and ignores empty lines (default: true).
     * @param {String} [options.lineSeparator] String that defines the end of a line (default `\n`).
     * @param {String} [options.outFormat] Output format (`constraints` or `raw`) (default: `constraints`).
     * @return {Array} Array of constraint definitions.
     */

  }, {
    key: 'parse',
    value: function parse(visualFormat, options) {
      var lineSeparator = options && options.lineSeparator ? options.lineSeparator : '\n';
      if (!Array.isArray(visualFormat) && visualFormat.indexOf(lineSeparator) < 0) {
        try {
          return this.parseLine(visualFormat, options);
        } catch (err) {
          err.source = visualFormat;
          throw err;
        }
      }

      // Decompose visual-format into an array of strings, and within those strings
      // search for line-endings, and treat each line as a seperate visual-format.
      visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
      var lines = void 0;
      var constraints = [];
      var lineIndex = 0;
      var line = void 0;
      var parseOptions = {
        lineIndex: lineIndex,
        extended: options && options.extended,
        strict: options && options.strict !== undefined ? options.strict : true,
        outFormat: options ? options.outFormat : undefined,
        subViews: {}
      };
      try {
        for (var i = 0; i < visualFormat.length; i++) {
          lines = visualFormat[i].split(lineSeparator);
          for (var j = 0; j < lines.length; j++) {
            line = lines[j];
            lineIndex++;
            parseOptions.lineIndex = lineIndex;
            if (!parseOptions.strict) {
              line = line.trim();
            }
            if (parseOptions.strict || line.length) {
              constraints = constraints.concat(this.parseLine(line, parseOptions));
            }
          }
        }
      } catch (err) {
        err.source = line;
        err.line = lineIndex;
        throw err;
      }
      return constraints;
    }

    /**
     * Parses meta information from the comments in the VFL.
     *
     * Additional meta information can be specified in the comments
     * for previewing and rendering purposes. For instance, the view-port
     * aspect-ratio, sub-view widths and colors, can be specified. The
     * following example renders three colored circles in the visual-format editor:
     *
     * ```vfl
     * //viewport aspect-ratio:3/1 max-height:300
     * //colors red:#FF0000 green:#00FF00 blue:#0000FF
     * //shapes red:circle green:circle blue:circle
     * H:|-[row:[red(green,blue)]-[green]-[blue]]-|
     * V:|[row]|
     * ```
     *
     * Supported categories and properties:
     *
     * |Category|Property|Example|
     * |--------|--------|-------|
     * |`viewport`|`aspect-ratio:{width}/{height}`|`//viewport aspect-ratio:16/9`|
     * ||`width:[{number}/intrinsic]`|`//viewport width:10`|
     * ||`height:[{number}/intrinsic]`|`//viewport height:intrinsic`|
     * ||`min-width:{number}`|
     * ||`max-width:{number}`|
     * ||`min-height:{number}`|
     * ||`max-height:{number}`|
     * |`spacing`|`[{number}/array]`|`//spacing:8` or `//spacing:[10, 20, 5]`|
     * |`widths`|`{view-name}:[{number}/intrinsic]`|`//widths subview1:100`|
     * |`heights`|`{view-name}:[{number}/intrinsic]`|`//heights subview1:intrinsic`|
     * |`colors`|`{view-name}:{color}`|`//colors redview:#FF0000 blueview:#00FF00`|
     * |`shapes`|`{view-name}:[circle/square]`|`//shapes avatar:circle`|
     *
     * @param {String|Array} visualFormat One or more visual format strings.
     * @param {Object} [options] Configuration options.
     * @param {String} [options.lineSeparator] String that defines the end of a line (default `\n`).
     * @param {String} [options.prefix] When specified, also processes the categories using that prefix (e.g. "-dev-viewport max-height:10").
     * @return {Object} meta-info
     */

  }, {
    key: 'parseMetaInfo',
    value: function parseMetaInfo(visualFormat, options) {
      var lineSeparator = options && options.lineSeparator ? options.lineSeparator : '\n';
      var prefix = options ? options.prefix : undefined;
      visualFormat = Array.isArray(visualFormat) ? visualFormat : [visualFormat];
      var metaInfo = {};
      var key;
      for (var k = 0; k < visualFormat.length; k++) {
        var lines = visualFormat[k].split(lineSeparator);
        for (var i = 0; i < lines.length; i++) {
          var line = lines[i];
          for (var c = 0; c < metaInfoCategories.length; c++) {
            for (var s = 0; s < (prefix ? 2 : 1); s++) {
              var category = metaInfoCategories[c];
              var prefixedCategory = (s === 0 ? '' : prefix) + category;
              if (line.indexOf('//' + prefixedCategory + ' ') === 0) {
                var items = line.substring(3 + prefixedCategory.length).split(' ');
                for (var j = 0; j < items.length; j++) {
                  metaInfo[category] = metaInfo[category] || {};
                  var item = items[j].split(':');
                  var names = _getRange(item[0], true);
                  for (var r = 0; r < names.length; r++) {
                    metaInfo[category][names[r]] = item.length > 1 ? item[1] : '';
                  }
                }
              } else if (line.indexOf('//' + prefixedCategory + ':') === 0) {
                metaInfo[category] = line.substring(3 + prefixedCategory.length);
              }
            }
          }
        }
      }
      if (metaInfo.viewport) {
        var viewport = metaInfo.viewport;
        var aspectRatio = viewport['aspect-ratio'];
        if (aspectRatio) {
          aspectRatio = aspectRatio.split('/');
          viewport['aspect-ratio'] = parseInt(aspectRatio[0]) / parseInt(aspectRatio[1]);
        }
        if (viewport.height !== undefined) {
          viewport.height = viewport.height === 'intrinsic' ? true : parseInt(viewport.height);
        }
        if (viewport.width !== undefined) {
          viewport.width = viewport.width === 'intrinsic' ? true : parseInt(viewport.width);
        }
        if (viewport['max-height'] !== undefined) {
          viewport['max-height'] = parseInt(viewport['max-height']);
        }
        if (viewport['max-width'] !== undefined) {
          viewport['max-width'] = parseInt(viewport['max-width']);
        }
        if (viewport['min-height'] !== undefined) {
          viewport['min-height'] = parseInt(viewport['min-height']);
        }
        if (viewport['min-width'] !== undefined) {
          viewport['min-width'] = parseInt(viewport['min-width']);
        }
      }
      if (metaInfo.widths) {
        for (key in metaInfo.widths) {
          var width = metaInfo.widths[key] === 'intrinsic' ? true : parseInt(metaInfo.widths[key]);
          metaInfo.widths[key] = width;
          if (width === undefined || isNaN(width)) {
            delete metaInfo.widths[key];
          }
        }
      }
      if (metaInfo.heights) {
        for (key in metaInfo.heights) {
          var height = metaInfo.heights[key] === 'intrinsic' ? true : parseInt(metaInfo.heights[key]);
          metaInfo.heights[key] = height;
          if (height === undefined || isNaN(height)) {
            delete metaInfo.heights[key];
          }
        }
      }
      if (metaInfo.spacing) {
        var value = JSON.parse(metaInfo.spacing);
        metaInfo.spacing = value;
        if (Array.isArray(value)) {
          for (var sIdx = 0, len = value.length; sIdx < len; sIdx++) {
            if (isNaN(value[sIdx])) {
              delete metaInfo.spacing;
              break;
            }
          }
        } else if (value === undefined || isNaN(value)) {
          delete metaInfo.spacing;
        }
      }
      return metaInfo;
    }
  }]);

  return VisualFormat;
}();

/**
 * A SubView is automatically generated when constraints are added to a View.
 *
 * @namespace SubView
 */


var SubView = function () {
  function SubView(options) {
    _classCallCheck(this, SubView);

    this._name = options.name;
    this._type = options.type;
    this._solver = options.solver;
    this._attr = {};
    if (!options.name) {
      if (true) {
        this._attr[Attribute.LEFT] = new c.Variable();
        this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.LEFT], c.Strength.required));
        this._attr[Attribute.TOP] = new c.Variable();
        this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.TOP], c.Strength.required));
        this._attr[Attribute.ZINDEX] = new c.Variable();
        this._solver.addConstraint(new c.StayConstraint(this._attr[Attribute.ZINDEX], c.Strength.required));
      } else {
        this._attr[Attribute.LEFT] = new kiwi.Variable();
        this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.LEFT], kiwi.Operator.Eq, 0));
        this._attr[Attribute.TOP] = new kiwi.Variable();
        this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.TOP], kiwi.Operator.Eq, 0));
        this._attr[Attribute.ZINDEX] = new kiwi.Variable();
        this._solver.addConstraint(new kiwi.Constraint(this._attr[Attribute.ZINDEX], kiwi.Operator.Eq, 0));
      }
    }
  }

  _createClass(SubView, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        name: this.name,
        left: this.left,
        top: this.top,
        width: this.width,
        height: this.height
      };
    }
  }, {
    key: 'toString',
    value: function toString() {
      JSON.stringify(this.toJSON(), undefined, 2);
    }

    /**
     * Name of the sub-view.
     * @readonly
     * @type {String}
     */

  }, {
    key: 'getValue',


    /**
     * Gets the value of one of the attributes.
     *
     * @param {String|Attribute} attr Attribute name (e.g. 'right', 'centerY', Attribute.TOP).
     * @return {Number} value or `undefined`
     */
    value: function getValue(attr) {
      return this._attr[attr] ? this._attr[attr].value() : undefined;
    }

    /**
     * @private
     */

  }, {
    key: '_getAttr',
    value: function _getAttr(attr) {
      if (this._attr[attr]) {
        return this._attr[attr];
      }
      this._attr[attr] = true ? new c.Variable() : new kiwi.Variable();
      switch (attr) {
        case Attribute.RIGHT:
          this._getAttr(Attribute.LEFT);
          this._getAttr(Attribute.WIDTH);
          if (true) {
            this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.LEFT], this._attr[Attribute.WIDTH])));
          } else {
            this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH])));
          }
          break;
        case Attribute.BOTTOM:
          this._getAttr(Attribute.TOP);
          this._getAttr(Attribute.HEIGHT);
          if (true) {
            this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.TOP], this._attr[Attribute.HEIGHT])));
          } else {
            this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT])));
          }
          break;
        case Attribute.CENTERX:
          this._getAttr(Attribute.LEFT);
          this._getAttr(Attribute.WIDTH);
          if (true) {
            this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.LEFT], c.divide(this._attr[Attribute.WIDTH], 2))));
          } else {
            this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.LEFT].plus(this._attr[Attribute.WIDTH].divide(2))));
          }
          break;
        case Attribute.CENTERY:
          this._getAttr(Attribute.TOP);
          this._getAttr(Attribute.HEIGHT);
          if (true) {
            this._solver.addConstraint(new c.Equation(this._attr[attr], c.plus(this._attr[Attribute.TOP], c.divide(this._attr[Attribute.HEIGHT], 2))));
          } else {
            this._solver.addConstraint(new kiwi.Constraint(this._attr[attr], kiwi.Operator.Eq, this._attr[Attribute.TOP].plus(this._attr[Attribute.HEIGHT].divide(2))));
          }
          break;
      }
      if (false) {
        this._solver.updateVariables();
      }
      return this._attr[attr];
    }

    /**
     * @private
     */

  }, {
    key: '_getAttrValue',
    value: function _getAttrValue(attr) {
      if (true) {
        return this._getAttr(attr).value;
      } else {
        return this._getAttr(attr).value();
      }
    }
  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }

    /**
     * Left value (`Attribute.LEFT`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'left',
    get: function get() {
      return this._getAttrValue(Attribute.LEFT);
    }

    /**
     * Right value (`Attribute.RIGHT`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'right',
    get: function get() {
      return this._getAttrValue(Attribute.RIGHT);
    }

    /**
     * Width value (`Attribute.WIDTH`).
     * @type {Number}
     */

  }, {
    key: 'width',
    get: function get() {
      return this._getAttrValue(Attribute.WIDTH);
    }

    /**
     * Height value (`Attribute.HEIGHT`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this._getAttrValue(Attribute.HEIGHT);
    }

    /**
     * Intrinsic width of the sub-view.
     *
     * Use this property to explicitely set the width of the sub-view, e.g.:
     * ```javascript
     * var view = new AutoLayout.View(AutoLayout.VisualFormat.parse('|[child1][child2]|'), {
     *   width: 500
     * });
     * view.subViews.child1.intrinsicWidth = 100;
     * console.log('child2 width: ' + view.subViews.child2.width); // 400
     * ```
     *
     * @type {Number}
     */

  }, {
    key: 'intrinsicWidth',
    get: function get() {
      return this._intrinsicWidth;
    },
    set: function set(value) {
      if (value !== undefined && value !== this._intrinsicWidth) {
        var attr = this._getAttr(Attribute.WIDTH);
        if (this._intrinsicWidth === undefined) {
          if (true) {
            this._solver.addEditVar(attr, new c.Strength('required', this._name ? 998 : 999, 1000, 1000));
          } else {
            this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
          }
        }
        this._intrinsicWidth = value;
        this._solver.suggestValue(attr, value);
        if (true) {
          this._solver.resolve();
        } else {
          this._solver.updateVariables();
        }
      }
    }

    /**
     * Intrinsic height of the sub-view.
     *
     * See `intrinsicWidth`.
     *
     * @type {Number}
     */

  }, {
    key: 'intrinsicHeight',
    get: function get() {
      return this._intrinsicHeight;
    },
    set: function set(value) {
      if (value !== undefined && value !== this._intrinsicHeight) {
        var attr = this._getAttr(Attribute.HEIGHT);
        if (this._intrinsicHeight === undefined) {
          if (true) {
            this._solver.addEditVar(attr, new c.Strength('required', this._name ? 998 : 999, 1000, 1000));
          } else {
            this._solver.addEditVariable(attr, kiwi.Strength.create(this._name ? 998 : 999, 1000, 1000));
          }
        }
        this._intrinsicHeight = value;
        this._solver.suggestValue(attr, value);
        if (true) {
          this._solver.resolve();
        } else {
          this._solver.updateVariables();
        }
      }
    }

    /**
     * Top value (`Attribute.TOP`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'top',
    get: function get() {
      return this._getAttrValue(Attribute.TOP);
    }

    /**
     * Bottom value (`Attribute.BOTTOM`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'bottom',
    get: function get() {
      return this._getAttrValue(Attribute.BOTTOM);
    }

    /**
     * Horizontal center (`Attribute.CENTERX`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'centerX',
    get: function get() {
      return this._getAttrValue(Attribute.CENTERX);
    }

    /**
     * Vertical center (`Attribute.CENTERY`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'centerY',
    get: function get() {
      return this._getAttrValue(Attribute.CENTERY);
    }

    /**
     * Z-index (`Attribute.ZINDEX`).
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'zIndex',
    get: function get() {
      return this._getAttrValue(Attribute.ZINDEX);
    }

    /**
     * Returns the type of the sub-view.
     * @readonly
     * @type {String}
     */

  }, {
    key: 'type',
    get: function get() {
      return this._type;
    }
  }]);

  return SubView;
}();

var defaultPriorityStrength = true ? new c.Strength('defaultPriority', 0, 1000, 1000) : kiwi.Strength.create(0, 1000, 1000);

function _getConst(name, value) {
  if (true) {
    var vr = new c.Variable({ value: value });
    this._solver.addConstraint(new c.StayConstraint(vr, c.Strength.required, 0));
    return vr;
  } else {
    var _vr = new kiwi.Variable();
    this._solver.addConstraint(new kiwi.Constraint(_vr, kiwi.Operator.Eq, value));
    return _vr;
  }
}

function _getSubView(viewName) {
  if (!viewName) {
    return this._parentSubView;
  } else if (viewName.name) {
    this._subViews[viewName.name] = this._subViews[viewName.name] || new SubView({
      name: viewName.name,
      solver: this._solver
    });
    this._subViews[viewName.name]._type = this._subViews[viewName.name]._type || viewName.type;
    return this._subViews[viewName.name];
  } else {
    this._subViews[viewName] = this._subViews[viewName] || new SubView({
      name: viewName,
      solver: this._solver
    });
    return this._subViews[viewName];
  }
}

function _getSpacing(constraint) {
  var index = 4;
  if (!constraint.view1 && constraint.attr1 === 'left') {
    index = 3;
  } else if (!constraint.view1 && constraint.attr1 === 'top') {
    index = 0;
  } else if (!constraint.view2 && constraint.attr2 === 'right') {
    index = 1;
  } else if (!constraint.view2 && constraint.attr2 === 'bottom') {
    index = 2;
  } else {
    switch (constraint.attr1) {
      case 'left':
      case 'right':
      case 'centerX':
      case 'leading':
      case 'trailing':
        index = 4;
        break;
      case 'zIndex':
        index = 6;
        break;
      default:
        index = 5;
    }
  }
  this._spacingVars = this._spacingVars || new Array(7);
  this._spacingExpr = this._spacingExpr || new Array(7);
  if (!this._spacingVars[index]) {
    if (true) {
      this._spacingVars[index] = new c.Variable();
      this._solver.addEditVar(this._spacingVars[index]);
      this._spacingExpr[index] = c.minus(0, this._spacingVars[index]);
    } else {
      this._spacingVars[index] = new kiwi.Variable();
      this._solver.addEditVariable(this._spacingVars[index], kiwi.Strength.create(999, 1000, 1000));
      this._spacingExpr[index] = this._spacingVars[index].multiply(-1);
    }
    this._solver.suggestValue(this._spacingVars[index], this._spacing[index]);
  }
  return this._spacingExpr[index];
}

function _addConstraint(constraint) {
  //this.constraints.push(constraint);
  var relation = void 0;
  var multiplier = constraint.multiplier !== undefined ? constraint.multiplier : 1;
  var constant = constraint.constant !== undefined ? constraint.constant : 0;
  if (constant === 'default') {
    constant = _getSpacing.call(this, constraint);
  }
  var attr1 = _getSubView.call(this, constraint.view1)._getAttr(constraint.attr1);
  var attr2 = void 0;
  if (true) {
    if (constraint.attr2 === Attribute.CONST) {
      attr2 = _getConst.call(this, undefined, constraint.constant);
    } else {
      attr2 = _getSubView.call(this, constraint.view2)._getAttr(constraint.attr2);
      if (multiplier !== 1 && constant) {
        attr2 = c.plus(c.times(attr2, multiplier), constant);
      } else if (constant) {
        attr2 = c.plus(attr2, constant);
      } else if (multiplier !== 1) {
        attr2 = c.times(attr2, multiplier);
      }
    }
    var strength = constraint.priority !== undefined && constraint.priority < 1000 ? new c.Strength('priority', 0, constraint.priority, 1000) : defaultPriorityStrength;
    switch (constraint.relation) {
      case Relation.EQU:
        relation = new c.Equation(attr1, attr2, strength);
        break;
      case Relation.GEQ:
        relation = new c.Inequality(attr1, c.GEQ, attr2, strength);
        break;
      case Relation.LEQ:
        relation = new c.Inequality(attr1, c.LEQ, attr2, strength);
        break;
      default:
        throw 'Invalid relation specified: ' + constraint.relation;
    }
  } else {
    if (constraint.attr2 === Attribute.CONST) {
      attr2 = _getConst.call(this, undefined, constraint.constant);
    } else {
      attr2 = _getSubView.call(this, constraint.view2)._getAttr(constraint.attr2);
      if (multiplier !== 1 && constant) {
        attr2 = attr2.multiply(multiplier).plus(constant);
      } else if (constant) {
        attr2 = attr2.plus(constant);
      } else if (multiplier !== 1) {
        attr2 = attr2.multiply(multiplier);
      }
    }
    var _strength = constraint.priority !== undefined && constraint.priority < 1000 ? kiwi.Strength.create(0, constraint.priority, 1000) : defaultPriorityStrength;
    switch (constraint.relation) {
      case Relation.EQU:
        relation = new kiwi.Constraint(attr1, kiwi.Operator.Eq, attr2, _strength);
        break;
      case Relation.GEQ:
        relation = new kiwi.Constraint(attr1, kiwi.Operator.Ge, attr2, _strength);
        break;
      case Relation.LEQ:
        relation = new kiwi.Constraint(attr1, kiwi.Operator.Le, attr2, _strength);
        break;
      default:
        throw 'Invalid relation specified: ' + constraint.relation;
    }
  }
  this._solver.addConstraint(relation);
}

function _compareSpacing(old, newz) {
  if (old === newz) {
    return true;
  }
  if (!old || !newz) {
    return false;
  }
  for (var i = 0; i < 7; i++) {
    if (old[i] !== newz[i]) {
      return false;
    }
  }
  return true;
}

/**
 * AutoLayoutJS API reference.
 *
 * ### Index
 *
 * |Entity|Type|Description|
 * |---|---|---|
 * |[AutoLayout](#autolayout)|`namespace`|Top level AutoLayout object.|
 * |[VisualFormat](#autolayoutvisualformat--object)|`namespace`|Parses VFL into constraints.|
 * |[View](#autolayoutview)|`class`|Main entity for adding & evaluating constraints.|
 * |[SubView](#autolayoutsubview--object)|`class`|SubView's are automatically created when constraints are added to views. They give access to the evaluated results.|
 * |[Attribute](#autolayoutattribute--enum)|`enum`|Attribute types that are supported when adding constraints.|
 * |[Relation](#autolayoutrelation--enum)|`enum`|Relationship types that are supported when adding constraints.|
 * |[Priority](#autolayoutpriority--enum)|`enum`|Default priority values for when adding constraints.|
 *
 * ### AutoLayout
 *
 * @module AutoLayout
 */

var View = function () {

  /**
   * @class View
   * @param {Object} [options] Configuration options.
   * @param {Number} [options.width] Initial width of the view.
   * @param {Number} [options.height] Initial height of the view.
   * @param {Number|Object} [options.spacing] Spacing for the view (default: 8) (see `setSpacing`).
   * @param {Array} [options.constraints] One or more constraint definitions (see `addConstraints`).
   */
  function View(options) {
    _classCallCheck(this, View);

    this._solver = true ? new c.SimplexSolver() : new kiwi.Solver();
    this._subViews = {};
    //this._spacing = undefined;
    this._parentSubView = new SubView({
      solver: this._solver
    });
    this.setSpacing(options && options.spacing !== undefined ? options.spacing : 8);
    //this.constraints = [];
    if (options) {
      if (options.width !== undefined || options.height !== undefined) {
        this.setSize(options.width, options.height);
      }
      if (options.constraints) {
        this.addConstraints(options.constraints);
      }
    }
  }

  /**
   * Sets the width and height of the view.
   *
   * @param {Number} width Width of the view.
   * @param {Number} height Height of the view.
   * @return {View} this
   */


  _createClass(View, [{
    key: 'setSize',
    value: function setSize(width, height /*, depth*/) {
      this._parentSubView.intrinsicWidth = width;
      this._parentSubView.intrinsicHeight = height;
      return this;
    }

    /**
     * Width that was set using `setSize`.
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'setSpacing',


    /**
     * Sets the spacing for the view.
     *
     * The spacing can be set for 7 different variables:
     * `top`, `right`, `bottom`, `left`, `width`, `height` and `zIndex`. The `left`-spacing is
     * used when a spacer is used between the parent-view and a sub-view (e.g. `|-[subView]`).
     * The same is true for the `right`, `top` and `bottom` spacers. The `width` and `height` are
     * used for spacers in between sub-views (e.g. `[view1]-[view2]`).
     *
     * Instead of using the full spacing syntax, it is also possible to use shorthand notations:
     *
     * |Syntax|Type|Description|
     * |---|---|---|
     * |`[top, right, bottom, left, width, height, zIndex]`|Array(7)|Full syntax including z-index **(clockwise order)**.|
     * |`[top, right, bottom, left, width, height]`|Array(6)|Full horizontal & vertical spacing syntax (no z-index) **(clockwise order)**.|
     * |`[horizontal, vertical, zIndex]`|Array(3)|Horizontal = left, right, width, vertical = top, bottom, height.|
     * |`[horizontal, vertical]`|Array(2)|Horizontal = left, right, width, vertical = top, bottom, height, z-index = 1.|
     * |`spacing`|Number|Horizontal & vertical spacing are all the same, z-index = 1.|
     *
     * Examples:
     * ```javascript
     * view.setSpacing(10); // horizontal & vertical spacing 10
     * view.setSpacing([10, 15, 2]); // horizontal spacing 10, vertical spacing 15, z-axis spacing 2
     * view.setSpacing([10, 20, 10, 20, 5, 5]); // top, right, bottom, left, horizontal, vertical
     * view.setSpacing([10, 20, 10, 20, 5, 5, 1]); // top, right, bottom, left, horizontal, vertical, z
     * ```
     *
     * @param {Number|Array} spacing
     * @return {View} this
     */
    value: function setSpacing(spacing) {
      // convert spacing into array: [top, right, bottom, left, horz, vert, z-index]
      switch (Array.isArray(spacing) ? spacing.length : -1) {
        case -1:
          spacing = [spacing, spacing, spacing, spacing, spacing, spacing, 1];break;
        case 1:
          spacing = [spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], spacing[0], 1];break;
        case 2:
          spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], 1];break;
        case 3:
          spacing = [spacing[1], spacing[0], spacing[1], spacing[0], spacing[0], spacing[1], spacing[2]];break;
        case 6:
          spacing = [spacing[0], spacing[1], spacing[2], spacing[3], spacing[4], spacing[5], 1];break;
        case 7:
          break;
        default:
          throw 'Invalid spacing syntax';
      }
      if (!_compareSpacing(this._spacing, spacing)) {
        this._spacing = spacing;
        // update spacing variables
        if (this._spacingVars) {
          for (var i = 0; i < this._spacingVars.length; i++) {
            if (this._spacingVars[i]) {
              this._solver.suggestValue(this._spacingVars[i], this._spacing[i]);
            }
          }
          if (true) {
            this._solver.resolve();
          } else {
            this._solver.updateVariables();
          }
        }
      }
      return this;
    }

    /**
     * Adds a constraint definition.
     *
     * A constraint definition has the following format:
     *
     * ```javascript
     * constraint: {
     *   view1: {String},
     *   attr1: {AutoLayout.Attribute},
     *   relation: {AutoLayout.Relation},
     *   view2: {String},
     *   attr2: {AutoLayout.Attribute},
     *   multiplier: {Number},
     *   constant: {Number},
     *   priority: {Number}(0..1000)
     * }
     * ```
     * @param {Object} constraint Constraint definition.
     * @return {View} this
     */

  }, {
    key: 'addConstraint',
    value: function addConstraint(constraint) {
      _addConstraint.call(this, constraint);
      if (false) {
        this._solver.updateVariables();
      }
      return this;
    }

    /**
     * Adds one or more constraint definitions.
     *
     * A constraint definition has the following format:
     *
     * ```javascript
     * constraint: {
     *   view1: {String},
     *   attr1: {AutoLayout.Attribute},
     *   relation: {AutoLayout.Relation},
     *   view2: {String},
     *   attr2: {AutoLayout.Attribute},
     *   multiplier: {Number},
     *   constant: {Number},
     *   priority: {Number}(0..1000)
     * }
     * ```
     * @param {Array} constraints One or more constraint definitions.
     * @return {View} this
     */

  }, {
    key: 'addConstraints',
    value: function addConstraints(constraints) {
      for (var j = 0; j < constraints.length; j++) {
        _addConstraint.call(this, constraints[j]);
      }
      if (false) {
        this._solver.updateVariables();
      }
      return this;
    }

    /**
     * Dictionary of `SubView` objects that have been created when adding constraints.
     * @readonly
     * @type {Object.SubView}
     */

  }, {
    key: 'width',
    get: function get() {
      return this._parentSubView.intrinsicWidth;
    }

    /**
     * Height that was set using `setSize`.
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'height',
    get: function get() {
      return this._parentSubView.intrinsicHeight;
    }

    /**
     * Width that is calculated from the constraints and the `.intrinsicWidth` of
     * the sub-views.
     *
     * When the width has been explicitely set using `setSize`, the fittingWidth
     * will **always** be the same as the explicitely set width. To calculate the size
     * based on the content, use:
     * ```javascript
     * var view = new AutoLayout.View({
     *   constraints: VisualFormat.parse('|-[view1]-[view2]-'),
     *   spacing: 20
     * });
     * view.subViews.view1.intrinsicWidth = 100;
     * view.subViews.view2.intrinsicWidth = 100;
     * console.log('fittingWidth: ' + view.fittingWidth); // 260
     * ```
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'fittingWidth',
    get: function get() {
      return this._parentSubView.width;
    }

    /**
     * Height that is calculated from the constraints and the `.intrinsicHeight` of
     * the sub-views.
     *
     * See `.fittingWidth`.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'fittingHeight',
    get: function get() {
      return this._parentSubView.height;
    }
  }, {
    key: 'subViews',
    get: function get() {
      return this._subViews;
    }

    /**
     * Checks whether the constraints incompletely specify the location
     * of the subViews.
     * @private
     */
    //get hasAmbiguousLayout() {
    // Todo
    //}

  }]);

  return View;
}();

//import DOM from './DOM';

/**
 * AutoLayout.
 *
 * @namespace AutoLayout
 * @property {Attribute} Attribute
 * @property {Relation} Relation
 * @property {Priority} Priority
 * @property {VisualFormat} VisualFormat
 * @property {View} View
 * @property {SubView} SubView
 */


var AutoLayout = {
  Attribute: Attribute,
  Relation: Relation,
  Priority: Priority,
  VisualFormat: VisualFormat,
  View: View,
  SubView: SubView
  //DOM: DOM
};

module.exports = AutoLayout;

},{"cassowary/bin/c":2}],2:[function(require,module,exports){
/**
 * Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)
 * Parts Copyright (C) Copyright (C) 1998-2000 Greg J. Badros
 *
 * Use of this source code is governed by the LGPL, which can be found in the
 * COPYING.LGPL file.
 *
 * This is a compiled version of Cassowary/JS. For source versions or to
 * contribute, see the github project:
 *
 *  https://github.com/slightlyoff/cassowary-js-refactor
 *
 */

(function() {
(function(a){"use strict";try{(function(){}).bind(a)}catch(b){Object.defineProperty(Function.prototype,"bind",{value:function(a){var b=this;return function(){return b.apply(a,arguments)}},enumerable:!1,configurable:!0,writable:!0})}var c=a.HTMLElement!==void 0,d=function(a){for(var b=null;a&&a!=Object.prototype;){if(a.tagName){b=a.tagName;break}a=a.prototype}return b||"div"},e=1e-8,f={},g=function(a,b){if(a&&b){if("function"==typeof a[b])return a[b];var c=a.prototype;if(c&&"function"==typeof c[b])return c[b];if(c!==Object.prototype&&c!==Function.prototype)return"function"==typeof a.__super__?g(a.__super__,b):void 0}},h=a.c={debug:!1,trace:!1,verbose:!1,traceAdded:!1,GC:!1,GEQ:1,LEQ:2,inherit:function(b){var e=null,g=null;b["extends"]&&(g=b["extends"],delete b["extends"]),b.initialize&&(e=b.initialize,delete b.initialize);var h=e||function(){};Object.defineProperty(h,"__super__",{value:g?g:Object,enumerable:!1,configurable:!0,writable:!1}),b._t&&(f[b._t]=h);var i=h.prototype=Object.create(g?g.prototype:Object.prototype);if(this.extend(i,b),c&&g&&g.prototype instanceof a.HTMLElement){var j=h,k=d(i),l=function(a){return a.__proto__=i,j.apply(a,arguments),i.created&&a.created(),i.decorate&&a.decorate(),a};this.extend(i,{upgrade:l}),h=function(){return l(a.document.createElement(k))},h.prototype=i,this.extend(h,{ctor:j})}return h},extend:function(a,b){return this.own(b,function(c){var d=Object.getOwnPropertyDescriptor(b,c);try{"function"==typeof d.get||"function"==typeof d.set?Object.defineProperty(a,c,d):"function"==typeof d.value||"_"===c.charAt(0)?(d.writable=!0,d.configurable=!0,d.enumerable=!1,Object.defineProperty(a,c,d)):a[c]=b[c]}catch(e){}}),a},own:function(b,c,d){return Object.getOwnPropertyNames(b).forEach(c,d||a),b},traceprint:function(a){h.verbose&&console.log(a)},fnenterprint:function(a){console.log("* "+a)},fnexitprint:function(a){console.log("- "+a)},assert:function(a,b){if(!a)throw new h.InternalError("Assertion failed: "+b)},plus:function(a,b){return a instanceof h.Expression||(a=new h.Expression(a)),b instanceof h.Expression||(b=new h.Expression(b)),a.plus(b)},minus:function(a,b){return a instanceof h.Expression||(a=new h.Expression(a)),b instanceof h.Expression||(b=new h.Expression(b)),a.minus(b)},times:function(a,b){return("number"==typeof a||a instanceof h.Variable)&&(a=new h.Expression(a)),("number"==typeof b||b instanceof h.Variable)&&(b=new h.Expression(b)),a.times(b)},divide:function(a,b){return("number"==typeof a||a instanceof h.Variable)&&(a=new h.Expression(a)),("number"==typeof b||b instanceof h.Variable)&&(b=new h.Expression(b)),a.divide(b)},approx:function(a,b){if(a===b)return!0;var c,d;return c=a instanceof h.Variable?a.value:a,d=b instanceof h.Variable?b.value:b,0==c?e>Math.abs(d):0==d?e>Math.abs(c):Math.abs(c-d)<Math.abs(c)*e},_inc:function(a){return function(){return a++}}(0),parseJSON:function(a){return JSON.parse(a,function(a,b){if("object"!=typeof b||"string"!=typeof b._t)return b;var c=b._t,d=f[c];if(c&&d){var e=g(d,"fromJSON");if(e)return e(b,d)}return b})}};"function"==typeof require&&"undefined"!=typeof module&&"undefined"==typeof load&&(a.exports=h)})(this),function(a){"use strict";var b=function(a){var b=a.hashCode?a.hashCode:""+a;return b},c=function(a,b){Object.keys(a).forEach(function(c){b[c]=a[c]})},d={};a.HashTable=a.inherit({initialize:function(){this.size=0,this._store={},this._keyStrMap={},this._deleted=0},set:function(a,c){var d=b(a);this._store.hasOwnProperty(d)||this.size++,this._store[d]=c,this._keyStrMap[d]=a},get:function(a){if(!this.size)return null;a=b(a);var c=this._store[a];return c!==void 0?this._store[a]:null},clear:function(){this.size=0,this._store={},this._keyStrMap={}},_compact:function(){var a={};c(this._store,a),this._store=a},_compactThreshold:100,_perhapsCompact:function(){this._size>64||this._deleted>this._compactThreshold&&(this._compact(),this._deleted=0)},"delete":function(a){a=b(a),this._store.hasOwnProperty(a)&&(this._deleted++,delete this._store[a],this.size>0&&this.size--)},each:function(a,b){if(this.size){this._perhapsCompact();var c=this._store,d=this._keyStrMap;Object.keys(this._store).forEach(function(e){a.call(b||null,d[e],c[e])},this)}},escapingEach:function(a,b){if(this.size){this._perhapsCompact();for(var c=this,e=this._store,f=this._keyStrMap,g=d,h=Object.keys(e),i=0;h.length>i;i++)if(function(d){c._store.hasOwnProperty(d)&&(g=a.call(b||null,f[d],e[d]))}(h[i]),g){if(void 0!==g.retval)return g;if(g.brk)break}}},clone:function(){var b=new a.HashTable;return this.size&&(b.size=this.size,c(this._store,b._store),c(this._keyStrMap,b._keyStrMap)),b},equals:function(b){if(b===this)return!0;if(!(b instanceof a.HashTable)||b._size!==this._size)return!1;for(var c=Object.keys(this._store),d=0;c.length>d;d++){var e=c[d];if(this._keyStrMap[e]!==b._keyStrMap[e]||this._store[e]!==b._store[e])return!1}return!0},toString:function(){var b="";return this.each(function(a,c){b+=a+" => "+c+"\n"}),b}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.HashSet=a.inherit({_t:"c.HashSet",initialize:function(){this.storage=[],this.size=0},add:function(a){var b=this.storage;b.indexOf(a),-1==b.indexOf(a)&&b.push(a),this.size=this.storage.length},values:function(){return this.storage},has:function(a){var b=this.storage;return-1!=b.indexOf(a)},"delete":function(a){var b=this.storage.indexOf(a);return-1==b?null:(this.storage.splice(b,1)[0],this.size=this.storage.length,void 0)},clear:function(){this.storage.length=0},each:function(a,b){this.size&&this.storage.forEach(a,b)},escapingEach:function(a,b){this.size&&this.storage.forEach(a,b)},toString:function(){var a=this.size+" {",b=!0;return this.each(function(c){b?b=!1:a+=", ",a+=c}),a+="}\n"},toJSON:function(){var a=[];return this.each(function(b){a.push(b.toJSON())}),{_t:"c.HashSet",data:a}},fromJSON:function(b){var c=new a.HashSet;return b.data&&(c.size=b.data.length,c.storage=b.data),c}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Error=a.inherit({initialize:function(a){a&&(this._description=a)},_name:"c.Error",_description:"An error has occured in Cassowary",set description(a){this._description=a},get description(){return"("+this._name+") "+this._description},get message(){return this.description},toString:function(){return this.description}});var b=function(b,c){return a.inherit({"extends":a.Error,initialize:function(){a.Error.apply(this,arguments)},_name:b||"",_description:c||""})};a.ConstraintNotFound=b("c.ConstraintNotFound","Tried to remove a constraint never added to the tableu"),a.InternalError=b("c.InternalError"),a.NonExpression=b("c.NonExpression","The resulting expression would be non"),a.NotEnoughStays=b("c.NotEnoughStays","There are not enough stays to give specific values to every variable"),a.RequiredFailure=b("c.RequiredFailure","A required constraint cannot be satisfied"),a.TooDifficult=b("c.TooDifficult","The constraints are too difficult to solve")}(this.c||module.parent.exports||{}),function(a){"use strict";var b=1e3;a.SymbolicWeight=a.inherit({_t:"c.SymbolicWeight",initialize:function(){this.value=0;for(var a=1,c=arguments.length-1;c>=0;--c)this.value+=arguments[c]*a,a*=b},toJSON:function(){return{_t:this._t,value:this.value}}})}(this.c||module.parent.exports||{}),function(a){a.Strength=a.inherit({initialize:function(b,c,d,e){this.name=b,this.symbolicWeight=c instanceof a.SymbolicWeight?c:new a.SymbolicWeight(c,d,e)},get required(){return this===a.Strength.required},toString:function(){return this.name+(this.isRequired?"":":"+this.symbolicWeight)}}),a.Strength.required=new a.Strength("<Required>",1e3,1e3,1e3),a.Strength.strong=new a.Strength("strong",1,0,0),a.Strength.medium=new a.Strength("medium",0,1,0),a.Strength.weak=new a.Strength("weak",0,0,1)}(this.c||("undefined"!=typeof module?module.parent.exports.c:{})),function(a){"use strict";a.AbstractVariable=a.inherit({isDummy:!1,isExternal:!1,isPivotable:!1,isRestricted:!1,_init:function(b,c){this.hashCode=a._inc(),this.name=(c||"")+this.hashCode,b&&(b.name!==void 0&&(this.name=b.name),b.value!==void 0&&(this.value=b.value),b.prefix!==void 0&&(this._prefix=b.prefix))},_prefix:"",name:"",value:0,toJSON:function(){var a={};return this._t&&(a._t=this._t),this.name&&(a.name=this.name),this.value!==void 0&&(a.value=this.value),this._prefix&&(a._prefix=this._prefix),this._t&&(a._t=this._t),a},fromJSON:function(b,c){var d=new c;return a.extend(d,b),d},toString:function(){return this._prefix+"["+this.name+":"+this.value+"]"}}),a.Variable=a.inherit({_t:"c.Variable","extends":a.AbstractVariable,initialize:function(b){this._init(b,"v");var c=a.Variable._map;c&&(c[this.name]=this)},isExternal:!0}),a.DummyVariable=a.inherit({_t:"c.DummyVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"d")},isDummy:!0,isRestricted:!0,value:"dummy"}),a.ObjectiveVariable=a.inherit({_t:"c.ObjectiveVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"o")},value:"obj"}),a.SlackVariable=a.inherit({_t:"c.SlackVariable","extends":a.AbstractVariable,initialize:function(a){this._init(a,"s")},isPivotable:!0,isRestricted:!0,value:"slack"})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Point=a.inherit({initialize:function(b,c,d){if(b instanceof a.Variable)this._x=b;else{var e={value:b};d&&(e.name="x"+d),this._x=new a.Variable(e)}if(c instanceof a.Variable)this._y=c;else{var f={value:c};d&&(f.name="y"+d),this._y=new a.Variable(f)}},get x(){return this._x},set x(b){b instanceof a.Variable?this._x=b:this._x.value=b},get y(){return this._y},set y(b){b instanceof a.Variable?this._y=b:this._y.value=b},toString:function(){return"("+this.x+", "+this.y+")"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Expression=a.inherit({initialize:function(b,c,d){a.GC&&console.log("new c.Expression"),this.constant="number"!=typeof d||isNaN(d)?0:d,this.terms=new a.HashTable,b instanceof a.AbstractVariable?this.setVariable(b,"number"==typeof c?c:1):"number"==typeof b&&(isNaN(b)?console.trace():this.constant=b)},initializeFromHash:function(b,c){return a.verbose&&(console.log("*******************************"),console.log("clone c.initializeFromHash"),console.log("*******************************")),a.GC&&console.log("clone c.Expression"),this.constant=b,this.terms=c.clone(),this},multiplyMe:function(a){this.constant*=a;var b=this.terms;return b.each(function(c,d){b.set(c,d*a)}),this},clone:function(){a.verbose&&(console.log("*******************************"),console.log("clone c.Expression"),console.log("*******************************"));var b=new a.Expression;return b.initializeFromHash(this.constant,this.terms),b},times:function(b){if("number"==typeof b)return this.clone().multiplyMe(b);if(this.isConstant)return b.times(this.constant);if(b.isConstant)return this.times(b.constant);throw new a.NonExpression},plus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,1):b instanceof a.Variable?this.clone().addVariable(b,1):void 0},minus:function(b){return b instanceof a.Expression?this.clone().addExpression(b,-1):b instanceof a.Variable?this.clone().addVariable(b,-1):void 0},divide:function(b){if("number"==typeof b){if(a.approx(b,0))throw new a.NonExpression;return this.times(1/b)}if(b instanceof a.Expression){if(!b.isConstant)throw new a.NonExpression;return this.times(1/b.constant)}},addExpression:function(b,c,d,e){return b instanceof a.AbstractVariable&&(b=new a.Expression(b),a.trace&&console.log("addExpression: Had to cast a var to an expression")),c=c||1,this.constant+=c*b.constant,b.terms.each(function(a,b){this.addVariable(a,b*c,d,e)},this),this},addVariable:function(b,c,d,e){null==c&&(c=1),a.trace&&console.log("c.Expression::addVariable():",b,c);var f=this.terms.get(b);if(f){var g=f+c;0==g||a.approx(g,0)?(e&&e.noteRemovedVariable(b,d),this.terms.delete(b)):this.setVariable(b,g)}else a.approx(c,0)||(this.setVariable(b,c),e&&e.noteAddedVariable(b,d));return this},setVariable:function(a,b){return this.terms.set(a,b),this},anyPivotableVariable:function(){if(this.isConstant)throw new a.InternalError("anyPivotableVariable called on a constant");var b=this.terms.escapingEach(function(a){return a.isPivotable?{retval:a}:void 0});return b&&void 0!==b.retval?b.retval:null},substituteOut:function(b,c,d,e){a.trace&&(a.fnenterprint("CLE:substituteOut: "+b+", "+c+", "+d+", ..."),a.traceprint("this = "+this));var f=this.setVariable.bind(this),g=this.terms,h=g.get(b);g.delete(b),this.constant+=h*c.constant,c.terms.each(function(b,c){var i=g.get(b);if(i){var j=i+h*c;a.approx(j,0)?(e.noteRemovedVariable(b,d),g.delete(b)):f(b,j)}else f(b,h*c),e&&e.noteAddedVariable(b,d)}),a.trace&&a.traceprint("Now this is "+this)},changeSubject:function(a,b){this.setVariable(a,this.newSubject(b))},newSubject:function(b){a.trace&&a.fnenterprint("newSubject:"+b);var c=1/this.terms.get(b);return this.terms.delete(b),this.multiplyMe(-c),c},coefficientFor:function(a){return this.terms.get(a)||0},get isConstant(){return 0==this.terms.size},toString:function(){var b="",c=!1;if(!a.approx(this.constant,0)||this.isConstant){if(b+=this.constant,this.isConstant)return b;c=!0}return this.terms.each(function(a,d){c&&(b+=" + "),b+=d+"*"+a,c=!0}),b},equals:function(b){return b===this?!0:b instanceof a.Expression&&b.constant===this.constant&&b.terms.equals(this.terms)},Plus:function(a,b){return a.plus(b)},Minus:function(a,b){return a.minus(b)},Times:function(a,b){return a.times(b)},Divide:function(a,b){return a.divide(b)}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.AbstractConstraint=a.inherit({initialize:function(b,c){this.hashCode=a._inc(),this.strength=b||a.Strength.required,this.weight=c||1},isEditConstraint:!1,isInequality:!1,isStayConstraint:!1,get required(){return this.strength===a.Strength.required},toString:function(){return this.strength+" {"+this.weight+"} ("+this.expression+")"}});var b=a.AbstractConstraint.prototype.toString,c=function(b,c,d){a.AbstractConstraint.call(this,c||a.Strength.strong,d),this.variable=b,this.expression=new a.Expression(b,-1,b.value)};a.EditConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isEditConstraint:!0,toString:function(){return"edit:"+b.call(this)}}),a.StayConstraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(){c.apply(this,arguments)},isStayConstraint:!0,toString:function(){return"stay:"+b.call(this)}});var d=a.Constraint=a.inherit({"extends":a.AbstractConstraint,initialize:function(b,c,d){a.AbstractConstraint.call(this,c,d),this.expression=b}});a.Inequality=a.inherit({"extends":a.Constraint,_cloneOrNewCle:function(b){return b.clone?b.clone():new a.Expression(b)},initialize:function(b,c,e,f,g){var h=b instanceof a.Expression,i=e instanceof a.Expression,j=b instanceof a.AbstractVariable,k=e instanceof a.AbstractVariable,l="number"==typeof b,m="number"==typeof e;if((h||l)&&k){var n=b,o=c,p=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else if(j&&(i||m)){var n=e,o=c,p=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(n),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addVariable(p);else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addVariable(p,-1)}}else{if(h&&m){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.LEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.GEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(l&&i){var s=e,o=c,t=b,q=f,r=g;if(d.call(this,this._cloneOrNewCle(s),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(t));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(t),-1)}return this}if(h&&i){var s=b,o=c,t=e,q=f,r=g;if(d.call(this,this._cloneOrNewCle(t),q,r),o==a.GEQ)this.expression.multiplyMe(-1),this.expression.addExpression(this._cloneOrNewCle(s));else{if(o!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");this.expression.addExpression(this._cloneOrNewCle(s),-1)}}else{if(h)return d.call(this,b,c,e);if(c==a.GEQ)d.call(this,new a.Expression(e),f,g),this.expression.multiplyMe(-1),this.expression.addVariable(b);else{if(c!=a.LEQ)throw new a.InternalError("Invalid operator in c.Inequality constructor");d.call(this,new a.Expression(e),f,g),this.expression.addVariable(b,-1)}}}},isInequality:!0,toString:function(){return d.prototype.toString.call(this)+" >= 0) id: "+this.hashCode}}),a.Equation=a.inherit({"extends":a.Constraint,initialize:function(b,c,e,f){if(b instanceof a.Expression&&!c||c instanceof a.Strength)d.call(this,b,c,e);else if(b instanceof a.AbstractVariable&&c instanceof a.Expression){var g=b,h=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.AbstractVariable&&"number"==typeof c){var g=b,k=c,i=e,j=f;d.call(this,new a.Expression(k),i,j),this.expression.addVariable(g,-1)}else if(b instanceof a.Expression&&c instanceof a.AbstractVariable){var h=b,g=c,i=e,j=f;d.call(this,h.clone(),i,j),this.expression.addVariable(g,-1)}else{if(!(b instanceof a.Expression||b instanceof a.AbstractVariable||"number"==typeof b)||!(c instanceof a.Expression||c instanceof a.AbstractVariable||"number"==typeof c))throw"Bad initializer to c.Equation";b=b instanceof a.Expression?b.clone():new a.Expression(b),c=c instanceof a.Expression?c.clone():new a.Expression(c),d.call(this,b,e,f),this.expression.addExpression(c,-1)}a.assert(this.strength instanceof a.Strength,"_strength not set")},toString:function(){return d.prototype.toString.call(this)+" = 0)"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.EditInfo=a.inherit({initialize:function(a,b,c,d,e){this.constraint=a,this.editPlus=b,this.editMinus=c,this.prevEditConstant=d,this.index=e},toString:function(){return"<cn="+this.constraint+", ep="+this.editPlus+", em="+this.editMinus+", pec="+this.prevEditConstant+", index="+this.index+">"}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Tableau=a.inherit({initialize:function(){this.columns=new a.HashTable,this.rows=new a.HashTable,this._infeasibleRows=new a.HashSet,this._externalRows=new a.HashSet,this._externalParametricVars=new a.HashSet},noteRemovedVariable:function(b,c){a.trace&&console.log("c.Tableau::noteRemovedVariable: ",b,c);var d=this.columns.get(b);c&&d&&d.delete(c)},noteAddedVariable:function(a,b){b&&this.insertColVar(a,b)},getInternalInfo:function(){var a="Tableau Information:\n";return a+="Rows: "+this.rows.size,a+=" (= "+(this.rows.size-1)+" constraints)",a+="\nColumns: "+this.columns.size,a+="\nInfeasible Rows: "+this._infeasibleRows.size,a+="\nExternal basic variables: "+this._externalRows.size,a+="\nExternal parametric variables: ",a+=this._externalParametricVars.size,a+="\n"},toString:function(){var a="Tableau:\n";return this.rows.each(function(b,c){a+=b,a+=" <==> ",a+=c,a+="\n"}),a+="\nColumns:\n",a+=this.columns,a+="\nInfeasible rows: ",a+=this._infeasibleRows,a+="External basic variables: ",a+=this._externalRows,a+="External parametric variables: ",a+=this._externalParametricVars},insertColVar:function(b,c){var d=this.columns.get(b);d||(d=new a.HashSet,this.columns.set(b,d)),d.add(c)},addRow:function(b,c){a.trace&&a.fnenterprint("addRow: "+b+", "+c),this.rows.set(b,c),c.terms.each(function(a){this.insertColVar(a,b),a.isExternal&&this._externalParametricVars.add(a)},this),b.isExternal&&this._externalRows.add(b),a.trace&&a.traceprint(""+this)},removeColumn:function(b){a.trace&&a.fnenterprint("removeColumn:"+b);var c=this.columns.get(b);c?(this.columns.delete(b),c.each(function(a){var c=this.rows.get(a);c.terms.delete(b)},this)):a.trace&&console.log("Could not find var",b,"in columns"),b.isExternal&&(this._externalRows.delete(b),this._externalParametricVars.delete(b))},removeRow:function(b){a.trace&&a.fnenterprint("removeRow:"+b);var c=this.rows.get(b);return a.assert(null!=c),c.terms.each(function(c){var e=this.columns.get(c);null!=e&&(a.trace&&console.log("removing from varset:",b),e.delete(b))},this),this._infeasibleRows.delete(b),b.isExternal&&this._externalRows.delete(b),this.rows.delete(b),a.trace&&a.fnexitprint("returning "+c),c},substituteOut:function(b,c){a.trace&&a.fnenterprint("substituteOut:"+b+", "+c),a.trace&&a.traceprint(""+this);var d=this.columns.get(b);d.each(function(a){var d=this.rows.get(a);d.substituteOut(b,c,a,this),a.isRestricted&&0>d.constant&&this._infeasibleRows.add(a)},this),b.isExternal&&(this._externalRows.add(b),this._externalParametricVars.delete(b)),this.columns.delete(b)},columnsHasKey:function(a){return!!this.columns.get(a)}})}(this.c||module.parent.exports||{}),function(a){var b=a.Tableau,c=b.prototype,d=1e-8,e=a.Strength.weak;a.SimplexSolver=a.inherit({"extends":a.Tableau,initialize:function(){a.Tableau.call(this),this._stayMinusErrorVars=[],this._stayPlusErrorVars=[],this._errorVars=new a.HashTable,this._markerVars=new a.HashTable,this._objective=new a.ObjectiveVariable({name:"Z"}),this._editVarMap=new a.HashTable,this._editVarList=[],this._slackCounter=0,this._artificialCounter=0,this._dummyCounter=0,this.autoSolve=!0,this._fNeedsSolving=!1,this._optimizeCount=0,this.rows.set(this._objective,new a.Expression),this._stkCedcns=[0],a.trace&&a.traceprint("objective expr == "+this.rows.get(this._objective))},addLowerBound:function(b,c){var d=new a.Inequality(b,a.GEQ,new a.Expression(c));return this.addConstraint(d)},addUpperBound:function(b,c){var d=new a.Inequality(b,a.LEQ,new a.Expression(c));return this.addConstraint(d)},addBounds:function(a,b,c){return this.addLowerBound(a,b),this.addUpperBound(a,c),this},add:function(){for(var a=0;arguments.length>a;a++)this.addConstraint(arguments[a]);return this},addConstraint:function(b){a.trace&&a.fnenterprint("addConstraint: "+b);var c=Array(2),d=Array(1),e=this.newExpression(b,c,d);if(d=d[0],this.tryAddingDirectly(e)||this.addWithArtificialVariable(e),this._fNeedsSolving=!0,b.isEditConstraint){var f=this._editVarMap.size,g=c[0],h=c[1];!g instanceof a.SlackVariable&&console.warn("cvEplus not a slack variable =",g),!h instanceof a.SlackVariable&&console.warn("cvEminus not a slack variable =",h),a.debug&&console.log("new c.EditInfo("+b+", "+g+", "+h+", "+d+", "+f+")");var i=new a.EditInfo(b,g,h,d,f);this._editVarMap.set(b.variable,i),this._editVarList[f]={v:b.variable,info:i}}return this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},addConstraintNoException:function(b){a.trace&&a.fnenterprint("addConstraintNoException: "+b);try{return this.addConstraint(b),!0}catch(c){return!1}},addEditVar:function(b,c){return a.trace&&a.fnenterprint("addEditVar: "+b+" @ "+c),this.addConstraint(new a.EditConstraint(b,c||a.Strength.strong))},beginEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this._infeasibleRows.clear(),this._resetStayConstants(),this._stkCedcns.push(this._editVarMap.size),this},endEdit:function(){return a.assert(this._editVarMap.size>0,"_editVarMap.size > 0"),this.resolve(),this._stkCedcns.pop(),this.removeEditVarsTo(this._stkCedcns[this._stkCedcns.length-1]),this},removeAllEditVars:function(){return this.removeEditVarsTo(0)},removeEditVarsTo:function(b){try{for(var c=this._editVarList.length,d=b;c>d;d++)this._editVarList[d]&&this.removeConstraint(this._editVarMap.get(this._editVarList[d].v).constraint);return this._editVarList.length=b,a.assert(this._editVarMap.size==b,"_editVarMap.size == n"),this}catch(e){throw new a.InternalError("Constraint not found in removeEditVarsTo")}},addPointStays:function(b){return a.trace&&console.log("addPointStays",b),b.forEach(function(a,b){this.addStay(a.x,e,Math.pow(2,b)),this.addStay(a.y,e,Math.pow(2,b))},this),this},addStay:function(b,c,d){var f=new a.StayConstraint(b,c||e,d||1);return this.addConstraint(f)},removeConstraint:function(a){return this.removeConstraintInternal(a),this},removeConstraintInternal:function(b){a.trace&&a.fnenterprint("removeConstraintInternal: "+b),a.trace&&a.traceprint(""+this),this._fNeedsSolving=!0,this._resetStayConstants();var c=this.rows.get(this._objective),d=this._errorVars.get(b);a.trace&&a.traceprint("eVars == "+d),null!=d&&d.each(function(e){var f=this.rows.get(e);null==f?c.addVariable(e,-b.weight*b.strength.symbolicWeight.value,this._objective,this):c.addExpression(f,-b.weight*b.strength.symbolicWeight.value,this._objective,this),a.trace&&a.traceprint("now eVars == "+d)},this);var e=this._markerVars.get(b);if(this._markerVars.delete(b),null==e)throw new a.InternalError("Constraint not found in removeConstraintInternal");if(a.trace&&a.traceprint("Looking to remove var "+e),null==this.rows.get(e)){var f=this.columns.get(e);a.trace&&a.traceprint("Must pivot -- columns are "+f);var g=null,h=0;f.each(function(b){if(b.isRestricted){var c=this.rows.get(b),d=c.coefficientFor(e);if(a.trace&&a.traceprint("Marker "+e+"'s coefficient in "+c+" is "+d),0>d){var f=-c.constant/d;(null==g||h>f||a.approx(f,h)&&b.hashCode<g.hashCode)&&(h=f,g=b)}}},this),null==g&&(a.trace&&a.traceprint("exitVar is still null"),f.each(function(a){if(a.isRestricted){var b=this.rows.get(a),c=b.coefficientFor(e),d=b.constant/c;(null==g||h>d)&&(h=d,g=a)}},this)),null==g&&(0==f.size?this.removeColumn(e):f.escapingEach(function(a){return a!=this._objective?(g=a,{brk:!0}):void 0},this)),null!=g&&this.pivot(e,g)}if(null!=this.rows.get(e)&&this.removeRow(e),null!=d&&d.each(function(a){a!=e&&this.removeColumn(a)},this),b.isStayConstraint){if(null!=d)for(var j=0;this._stayPlusErrorVars.length>j;j++)d.delete(this._stayPlusErrorVars[j]),d.delete(this._stayMinusErrorVars[j])}else if(b.isEditConstraint){a.assert(null!=d,"eVars != null");var k=this._editVarMap.get(b.variable);this.removeColumn(k.editMinus),this._editVarMap.delete(b.variable)}return null!=d&&this._errorVars.delete(d),this.autoSolve&&(this.optimize(this._objective),this._setExternalVariables()),this},reset:function(){throw a.trace&&a.fnenterprint("reset"),new a.InternalError("reset not implemented")},resolveArray:function(b){a.trace&&a.fnenterprint("resolveArray"+b);var c=b.length;this._editVarMap.each(function(a,d){var e=d.index;c>e&&this.suggestValue(a,b[e])},this),this.resolve()},resolvePair:function(a,b){this.suggestValue(this._editVarList[0].v,a),this.suggestValue(this._editVarList[1].v,b),this.resolve()},resolve:function(){a.trace&&a.fnenterprint("resolve()"),this.dualOptimize(),this._setExternalVariables(),this._infeasibleRows.clear(),this._resetStayConstants()},suggestValue:function(b,c){a.trace&&console.log("suggestValue("+b+", "+c+")");var d=this._editVarMap.get(b);if(!d)throw new a.Error("suggestValue for variable "+b+", but var is not an edit variable");var e=c-d.prevEditConstant;return d.prevEditConstant=c,this.deltaEditConstant(e,d.editPlus,d.editMinus),this},solve:function(){return this._fNeedsSolving&&(this.optimize(this._objective),this._setExternalVariables()),this},setEditedValue:function(b,c){if(!this.columnsHasKey(b)&&null==this.rows.get(b))return b.value=c,this;if(!a.approx(c,b.value)){this.addEditVar(b),this.beginEdit();try{this.suggestValue(b,c)}catch(d){throw new a.InternalError("Error in setEditedValue")}this.endEdit()}return this},addVar:function(b){if(!this.columnsHasKey(b)&&null==this.rows.get(b)){try{this.addStay(b)}catch(c){throw new a.InternalError("Error in addVar -- required failure is impossible")}a.trace&&a.traceprint("added initial stay on "+b)}return this},getInternalInfo:function(){var a=c.getInternalInfo.call(this);return a+="\nSolver info:\n",a+="Stay Error Variables: ",a+=this._stayPlusErrorVars.length+this._stayMinusErrorVars.length,a+=" ("+this._stayPlusErrorVars.length+" +, ",a+=this._stayMinusErrorVars.length+" -)\n",a+="Edit Variables: "+this._editVarMap.size,a+="\n"},getDebugInfo:function(){return""+this+this.getInternalInfo()+"\n"},toString:function(){var a=c.getInternalInfo.call(this);return a+="\n_stayPlusErrorVars: ",a+="["+this._stayPlusErrorVars+"]",a+="\n_stayMinusErrorVars: ",a+="["+this._stayMinusErrorVars+"]",a+="\n",a+="_editVarMap:\n"+this._editVarMap,a+="\n"},getConstraintMap:function(){return this._markerVars},addWithArtificialVariable:function(b){a.trace&&a.fnenterprint("addWithArtificialVariable: "+b);var c=new a.SlackVariable({value:++this._artificialCounter,prefix:"a"}),d=new a.ObjectiveVariable({name:"az"}),e=b.clone();a.trace&&a.traceprint("before addRows:\n"+this),this.addRow(d,e),this.addRow(c,b),a.trace&&a.traceprint("after addRows:\n"+this),this.optimize(d);var f=this.rows.get(d);if(a.trace&&a.traceprint("azTableauRow.constant == "+f.constant),!a.approx(f.constant,0))throw this.removeRow(d),this.removeColumn(c),new a.RequiredFailure;var g=this.rows.get(c);if(null!=g){if(g.isConstant)return this.removeRow(c),this.removeRow(d),void 0;var h=g.anyPivotableVariable();this.pivot(h,c)}a.assert(null==this.rows.get(c),"rowExpression(av) == null"),this.removeColumn(c),this.removeRow(d)},tryAddingDirectly:function(b){a.trace&&a.fnenterprint("tryAddingDirectly: "+b);var c=this.chooseSubject(b);return null==c?(a.trace&&a.fnexitprint("returning false"),!1):(b.newSubject(c),this.columnsHasKey(c)&&this.substituteOut(c,b),this.addRow(c,b),a.trace&&a.fnexitprint("returning true"),!0)},chooseSubject:function(b){a.trace&&a.fnenterprint("chooseSubject: "+b);var c=null,d=!1,e=!1,f=b.terms,g=f.escapingEach(function(a,b){if(d){if(!a.isRestricted&&!this.columnsHasKey(a))return{retval:a}}else if(a.isRestricted){if(!e&&!a.isDummy&&0>b){var f=this.columns.get(a);(null==f||1==f.size&&this.columnsHasKey(this._objective))&&(c=a,e=!0)}}else c=a,d=!0},this);if(g&&void 0!==g.retval)return g.retval;if(null!=c)return c;var h=0,g=f.escapingEach(function(a,b){return a.isDummy?(this.columnsHasKey(a)||(c=a,h=b),void 0):{retval:null}},this);if(g&&void 0!==g.retval)return g.retval;if(!a.approx(b.constant,0))throw new a.RequiredFailure;return h>0&&b.multiplyMe(-1),c},deltaEditConstant:function(b,c,d){a.trace&&a.fnenterprint("deltaEditConstant :"+b+", "+c+", "+d);var e=this.rows.get(c);if(null!=e)return e.constant+=b,0>e.constant&&this._infeasibleRows.add(c),void 0;var f=this.rows.get(d);if(null!=f)return f.constant+=-b,0>f.constant&&this._infeasibleRows.add(d),void 0;var g=this.columns.get(d);g||console.log("columnVars is null -- tableau is:\n"+this),g.each(function(a){var c=this.rows.get(a),e=c.coefficientFor(d);c.constant+=e*b,a.isRestricted&&0>c.constant&&this._infeasibleRows.add(a)},this)},dualOptimize:function(){a.trace&&a.fnenterprint("dualOptimize:");for(var b=this.rows.get(this._objective);this._infeasibleRows.size;){var c=this._infeasibleRows.values()[0];this._infeasibleRows.delete(c);var d=null,e=this.rows.get(c);if(e&&0>e.constant){var g,f=Number.MAX_VALUE,h=e.terms;if(h.each(function(c,e){if(e>0&&c.isPivotable){var h=b.coefficientFor(c);g=h/e,(f>g||a.approx(g,f)&&c.hashCode<d.hashCode)&&(d=c,f=g)}}),f==Number.MAX_VALUE)throw new a.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");this.pivot(d,c)}}},newExpression:function(b,c,d){a.trace&&(a.fnenterprint("newExpression: "+b),a.traceprint("cn.isInequality == "+b.isInequality),a.traceprint("cn.required == "+b.required));var e=b.expression,f=new a.Expression(e.constant),g=new a.SlackVariable,h=new a.DummyVariable,i=new a.SlackVariable,j=new a.SlackVariable,k=e.terms;if(k.each(function(a,b){var c=this.rows.get(a);c?f.addExpression(c,b):f.addVariable(a,b)},this),b.isInequality){if(a.trace&&a.traceprint("Inequality, adding slack"),++this._slackCounter,g=new a.SlackVariable({value:this._slackCounter,prefix:"s"}),f.setVariable(g,-1),this._markerVars.set(b,g),!b.required){++this._slackCounter,i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),f.setVariable(i,1);
var l=this.rows.get(this._objective);l.setVariable(i,b.strength.symbolicWeight.value*b.weight),this.insertErrorVar(b,i),this.noteAddedVariable(i,this._objective)}}else if(b.required)a.trace&&a.traceprint("Equality, required"),++this._dummyCounter,h=new a.DummyVariable({value:this._dummyCounter,prefix:"d"}),f.setVariable(h,1),this._markerVars.set(b,h),a.trace&&a.traceprint("Adding dummyVar == d"+this._dummyCounter);else{a.trace&&a.traceprint("Equality, not required"),++this._slackCounter,j=new a.SlackVariable({value:this._slackCounter,prefix:"ep"}),i=new a.SlackVariable({value:this._slackCounter,prefix:"em"}),f.setVariable(j,-1),f.setVariable(i,1),this._markerVars.set(b,j);var l=this.rows.get(this._objective);a.trace&&console.log(l);var m=b.strength.symbolicWeight.value*b.weight;0==m&&(a.trace&&a.traceprint("cn == "+b),a.trace&&a.traceprint("adding "+j+" and "+i+" with swCoeff == "+m)),l.setVariable(j,m),this.noteAddedVariable(j,this._objective),l.setVariable(i,m),this.noteAddedVariable(i,this._objective),this.insertErrorVar(b,i),this.insertErrorVar(b,j),b.isStayConstraint?(this._stayPlusErrorVars.push(j),this._stayMinusErrorVars.push(i)):b.isEditConstraint&&(c[0]=j,c[1]=i,d[0]=e.constant)}return 0>f.constant&&f.multiplyMe(-1),a.trace&&a.fnexitprint("returning "+f),f},optimize:function(b){a.trace&&a.fnenterprint("optimize: "+b),a.trace&&a.traceprint(""+this),this._optimizeCount++;var c=this.rows.get(b);a.assert(null!=c,"zRow != null");for(var g,h,e=null,f=null;;){if(g=0,h=c.terms,h.escapingEach(function(a,b){return a.isPivotable&&g>b?(g=b,e=a,{brk:1}):void 0},this),g>=-d)return;a.trace&&console.log("entryVar:",e,"objectiveCoeff:",g);var i=Number.MAX_VALUE,j=this.columns.get(e),k=0;if(j.each(function(b){if(a.trace&&a.traceprint("Checking "+b),b.isPivotable){var c=this.rows.get(b),d=c.coefficientFor(e);a.trace&&a.traceprint("pivotable, coeff = "+d),0>d&&(k=-c.constant/d,(i>k||a.approx(k,i)&&b.hashCode<f.hashCode)&&(i=k,f=b))}},this),i==Number.MAX_VALUE)throw new a.InternalError("Objective function is unbounded in optimize");this.pivot(e,f),a.trace&&a.traceprint(""+this)}},pivot:function(b,c){a.trace&&console.log("pivot: ",b,c);var d=!1;d&&console.time(" SimplexSolver::pivot"),null==b&&console.warn("pivot: entryVar == null"),null==c&&console.warn("pivot: exitVar == null"),d&&console.time("  removeRow");var e=this.removeRow(c);d&&console.timeEnd("  removeRow"),d&&console.time("  changeSubject"),e.changeSubject(c,b),d&&console.timeEnd("  changeSubject"),d&&console.time("  substituteOut"),this.substituteOut(b,e),d&&console.timeEnd("  substituteOut"),d&&console.time("  addRow"),this.addRow(b,e),d&&console.timeEnd("  addRow"),d&&console.timeEnd(" SimplexSolver::pivot")},_resetStayConstants:function(){a.trace&&console.log("_resetStayConstants");for(var b=0;this._stayPlusErrorVars.length>b;b++){var c=this.rows.get(this._stayPlusErrorVars[b]);null==c&&(c=this.rows.get(this._stayMinusErrorVars[b])),null!=c&&(c.constant=0)}},_setExternalVariables:function(){a.trace&&a.fnenterprint("_setExternalVariables:"),a.trace&&a.traceprint(""+this),this._externalParametricVars.each(function(b){null!=this.rows.get(b)?a.trace&&console.log("Error: variable"+b+" in _externalParametricVars is basic"):b.value=0},this),this._externalRows.each(function(a){var b=this.rows.get(a);a.value!=b.constant&&(a.value=b.constant)},this),this._fNeedsSolving=!1,this.onsolved()},onsolved:function(){},insertErrorVar:function(b,c){a.trace&&a.fnenterprint("insertErrorVar:"+b+", "+c);var d=this._errorVars.get(c);d||(d=new a.HashSet,this._errorVars.set(b,d)),d.add(c)}})}(this.c||module.parent.exports||{}),function(a){"use strict";a.Timer=a.inherit({initialize:function(){this.isRunning=!1,this._elapsedMs=0},start:function(){return this.isRunning=!0,this._startReading=new Date,this},stop:function(){return this.isRunning=!1,this._elapsedMs+=new Date-this._startReading,this},reset:function(){return this.isRunning=!1,this._elapsedMs=0,this},elapsedTime:function(){return this.isRunning?(this._elapsedMs+(new Date-this._startReading))/1e3:this._elapsedMs/1e3}})}(this.c||module.parent.exports||{}),__cassowary_parser=function(){function a(a){return'"'+a.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g,escape)+'"'}var b={parse:function(b,c){function k(a){g>e||(e>g&&(g=e,h=[]),h.push(a))}function l(){var a,b,c,d,f;if(d=e,f=e,a=z(),null!==a){if(c=m(),null!==c)for(b=[];null!==c;)b.push(c),c=m();else b=null;null!==b?(c=z(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)}else a=null,e=f;return null!==a&&(a=function(a,b){return b}(d,a[1])),null===a&&(e=d),a}function m(){var a,b,c,d;return c=e,d=e,a=P(),null!==a?(b=s(),null!==b?a=[a,b]:(a=null,e=d)):(a=null,e=d),null!==a&&(a=function(a,b){return b}(c,a[0])),null===a&&(e=c),a}function n(){var a;return b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),a}function o(){var a;return/^[a-zA-Z]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[a-zA-Z]")),null===a&&(36===b.charCodeAt(e)?(a="$",e++):(a=null,0===f&&k('"$"')),null===a&&(95===b.charCodeAt(e)?(a="_",e++):(a=null,0===f&&k('"_"')))),a}function p(){var a;return f++,/^[\t\x0B\f \xA0\uFEFF]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\t\\x0B\\f \\xA0\\uFEFF]")),f--,0===f&&null===a&&k("whitespace"),a}function q(){var a;return/^[\n\r\u2028\u2029]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\n\\r\\u2028\\u2029]")),a}function r(){var a;return f++,10===b.charCodeAt(e)?(a="\n",e++):(a=null,0===f&&k('"\\n"')),null===a&&("\r\n"===b.substr(e,2)?(a="\r\n",e+=2):(a=null,0===f&&k('"\\r\\n"')),null===a&&(13===b.charCodeAt(e)?(a="\r",e++):(a=null,0===f&&k('"\\r"')),null===a&&(8232===b.charCodeAt(e)?(a="\u2028",e++):(a=null,0===f&&k('"\\u2028"')),null===a&&(8233===b.charCodeAt(e)?(a="\u2029",e++):(a=null,0===f&&k('"\\u2029"')))))),f--,0===f&&null===a&&k("end of line"),a}function s(){var a,c,d;return d=e,a=z(),null!==a?(59===b.charCodeAt(e)?(c=";",e++):(c=null,0===f&&k('";"')),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=y(),null!==a?(c=r(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d),null===a&&(d=e,a=z(),null!==a?(c=t(),null!==c?a=[a,c]:(a=null,e=d)):(a=null,e=d))),a}function t(){var a,c;return c=e,f++,b.length>e?(a=b.charAt(e),e++):(a=null,0===f&&k("any character")),f--,null===a?a="":(a=null,e=c),a}function u(){var a;return f++,a=v(),null===a&&(a=x()),f--,0===f&&null===a&&k("comment"),a}function v(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function w(){var a,c,d,g,h,i,j;if(h=e,"/*"===b.substr(e,2)?(a="/*",e+=2):(a=null,0===f&&k('"/*"')),null!==a){for(c=[],i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=q()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,"*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null===d&&(d=q()),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?("*/"===b.substr(e,2)?(d="*/",e+=2):(d=null,0===f&&k('"*/"')),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)}else a=null,e=h;return a}function x(){var a,c,d,g,h,i,j;if(h=e,"//"===b.substr(e,2)?(a="//",e+=2):(a=null,0===f&&k('"//"')),null!==a){for(c=[],i=e,j=e,f++,d=q(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==d;)c.push(d),i=e,j=e,f++,d=q(),f--,null===d?d="":(d=null,e=j),null!==d?(g=n(),null!==g?d=[d,g]:(d=null,e=i)):(d=null,e=i);null!==c?a=[a,c]:(a=null,e=h)}else a=null,e=h;return a}function y(){var a,b;for(a=[],b=p(),null===b&&(b=w(),null===b&&(b=x()));null!==b;)a.push(b),b=p(),null===b&&(b=w(),null===b&&(b=x()));return a}function z(){var a,b;for(a=[],b=p(),null===b&&(b=r(),null===b&&(b=u()));null!==b;)a.push(b),b=p(),null===b&&(b=r(),null===b&&(b=u()));return a}function A(){var a,b;return b=e,a=C(),null===a&&(a=B()),null!==a&&(a=function(a,b){return{type:"NumericLiteral",value:b}}(b,a)),null===a&&(e=b),a}function B(){var a,c,d;if(d=e,/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]")),null!==c)for(a=[];null!==c;)a.push(c),/^[0-9]/.test(b.charAt(e))?(c=b.charAt(e),e++):(c=null,0===f&&k("[0-9]"));else a=null;return null!==a&&(a=function(a,b){return parseInt(b.join(""))}(d,a)),null===a&&(e=d),a}function C(){var a,c,d,g,h;return g=e,h=e,a=B(),null!==a?(46===b.charCodeAt(e)?(c=".",e++):(c=null,0===f&&k('"."')),null!==c?(d=B(),null!==d?a=[a,c,d]:(a=null,e=h)):(a=null,e=h)):(a=null,e=h),null!==a&&(a=function(a,b){return parseFloat(b.join(""))}(g,a)),null===a&&(e=g),a}function D(){var a,c,d,g;if(g=e,/^[\-+]/.test(b.charAt(e))?(a=b.charAt(e),e++):(a=null,0===f&&k("[\\-+]")),a=null!==a?a:"",null!==a){if(/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]")),null!==d)for(c=[];null!==d;)c.push(d),/^[0-9]/.test(b.charAt(e))?(d=b.charAt(e),e++):(d=null,0===f&&k("[0-9]"));else c=null;null!==c?a=[a,c]:(a=null,e=g)}else a=null,e=g;return a}function E(){var a,b;return f++,b=e,a=F(),null!==a&&(a=function(a,b){return b}(b,a)),null===a&&(e=b),f--,0===f&&null===a&&k("identifier"),a}function F(){var a,b,c,d,g;if(f++,d=e,g=e,a=o(),null!==a){for(b=[],c=o();null!==c;)b.push(c),c=o();null!==b?a=[a,b]:(a=null,e=g)}else a=null,e=g;return null!==a&&(a=function(a,b,c){return b+c.join("")}(d,a[0],a[1])),null===a&&(e=d),f--,0===f&&null===a&&k("identifier"),a}function G(){var a,c,d,g,h,i,j;return i=e,a=E(),null!==a&&(a=function(a,b){return{type:"Variable",name:b}}(i,a)),null===a&&(e=i),null===a&&(a=A(),null===a&&(i=e,j=e,40===b.charCodeAt(e)?(a="(",e++):(a=null,0===f&&k('"("')),null!==a?(c=z(),null!==c?(d=P(),null!==d?(g=z(),null!==g?(41===b.charCodeAt(e)?(h=")",e++):(h=null,0===f&&k('")"')),null!==h?a=[a,c,d,g,h]:(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j)):(a=null,e=j),null!==a&&(a=function(a,b){return b}(i,a[2])),null===a&&(e=i))),a}function H(){var a,b,c,d,f;return a=G(),null===a&&(d=e,f=e,a=I(),null!==a?(b=z(),null!==b?(c=H(),null!==c?a=[a,b,c]:(a=null,e=f)):(a=null,e=f)):(a=null,e=f),null!==a&&(a=function(a,b,c){return{type:"UnaryExpression",operator:b,expression:c}}(d,a[0],a[2])),null===a&&(e=d)),a}function I(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"')),null===a&&(33===b.charCodeAt(e)?(a="!",e++):(a=null,0===f&&k('"!"')))),a}function J(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=H(),null!==a){for(b=[],j=e,c=z(),null!==c?(d=K(),null!==d?(f=z(),null!==f?(g=H(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=z(),null!==c?(d=K(),null!==d?(f=z(),null!==f?(g=H(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;c.length>e;e++)d={type:"MultiplicativeExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function K(){var a;return 42===b.charCodeAt(e)?(a="*",e++):(a=null,0===f&&k('"*"')),null===a&&(47===b.charCodeAt(e)?(a="/",e++):(a=null,0===f&&k('"/"'))),a}function L(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=J(),null!==a){for(b=[],j=e,c=z(),null!==c?(d=M(),null!==d?(f=z(),null!==f?(g=J(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=z(),null!==c?(d=M(),null!==d?(f=z(),null!==f?(g=J(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;c.length>e;e++)d={type:"AdditiveExpression",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function M(){var a;return 43===b.charCodeAt(e)?(a="+",e++):(a=null,0===f&&k('"+"')),null===a&&(45===b.charCodeAt(e)?(a="-",e++):(a=null,0===f&&k('"-"'))),a}function N(){var a,b,c,d,f,g,h,i,j;if(h=e,i=e,a=L(),null!==a){for(b=[],j=e,c=z(),null!==c?(d=O(),null!==d?(f=z(),null!==f?(g=L(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==c;)b.push(c),j=e,c=z(),null!==c?(d=O(),null!==d?(f=z(),null!==f?(g=L(),null!==g?c=[c,d,f,g]:(c=null,e=j)):(c=null,e=j)):(c=null,e=j)):(c=null,e=j);null!==b?a=[a,b]:(a=null,e=i)}else a=null,e=i;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;c.length>e;e++)d={type:"Inequality",operator:c[e][1],left:d,right:c[e][3]};return d}(h,a[0],a[1])),null===a&&(e=h),a}function O(){var a;return"<="===b.substr(e,2)?(a="<=",e+=2):(a=null,0===f&&k('"<="')),null===a&&(">="===b.substr(e,2)?(a=">=",e+=2):(a=null,0===f&&k('">="')),null===a&&(60===b.charCodeAt(e)?(a="<",e++):(a=null,0===f&&k('"<"')),null===a&&(62===b.charCodeAt(e)?(a=">",e++):(a=null,0===f&&k('">"'))))),a}function P(){var a,c,d,g,h,i,j,l,m;if(j=e,l=e,a=N(),null!==a){for(c=[],m=e,d=z(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=z(),null!==h?(i=N(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==d;)c.push(d),m=e,d=z(),null!==d?("=="===b.substr(e,2)?(g="==",e+=2):(g=null,0===f&&k('"=="')),null!==g?(h=z(),null!==h?(i=N(),null!==i?d=[d,g,h,i]:(d=null,e=m)):(d=null,e=m)):(d=null,e=m)):(d=null,e=m);null!==c?a=[a,c]:(a=null,e=l)}else a=null,e=l;return null!==a&&(a=function(a,b,c){for(var d=b,e=0;c.length>e;e++)d={type:"Equality",operator:c[e][1],left:d,right:c[e][3]};return d}(j,a[0],a[1])),null===a&&(e=j),a}function Q(a){a.sort();for(var b=null,c=[],d=0;a.length>d;d++)a[d]!==b&&(c.push(a[d]),b=a[d]);return c}function R(){for(var a=1,c=1,d=!1,f=0;Math.max(e,g)>f;f++){var h=b.charAt(f);"\n"===h?(d||a++,c=1,d=!1):"\r"===h||"\u2028"===h||"\u2029"===h?(a++,c=1,d=!0):(c++,d=!1)}return{line:a,column:c}}var d={start:l,Statement:m,SourceCharacter:n,IdentifierStart:o,WhiteSpace:p,LineTerminator:q,LineTerminatorSequence:r,EOS:s,EOF:t,Comment:u,MultiLineComment:v,MultiLineCommentNoLineTerminator:w,SingleLineComment:x,_:y,__:z,Literal:A,Integer:B,Real:C,SignedInteger:D,Identifier:E,IdentifierName:F,PrimaryExpression:G,UnaryExpression:H,UnaryOperator:I,MultiplicativeExpression:J,MultiplicativeOperator:K,AdditiveExpression:L,AdditiveOperator:M,InequalityExpression:N,InequalityOperator:O,LinearExpression:P};if(void 0!==c){if(void 0===d[c])throw Error("Invalid rule name: "+a(c)+".")}else c="start";var e=0,f=0,g=0,h=[],S=d[c]();if(null===S||e!==b.length){var T=Math.max(e,g),U=b.length>T?b.charAt(T):null,V=R();throw new this.SyntaxError(Q(h),U,T,V.line,V.column)}return S},toSource:function(){return this._source}};return b.SyntaxError=function(b,c,d,e,f){function g(b,c){var d,e;switch(b.length){case 0:d="end of input";break;case 1:d=b[0];break;default:d=b.slice(0,b.length-1).join(", ")+" or "+b[b.length-1]}return e=c?a(c):"end of input","Expected "+d+" but "+e+" found."}this.name="SyntaxError",this.expected=b,this.found=c,this.message=g(b,c),this.offset=d,this.line=e,this.column=f},b.SyntaxError.prototype=Error.prototype,b}();
}).call(
  (typeof module != "undefined") ?
      (module.compiled = true && module) : this
);

},{}]},{},[1])(1)
});

/***/ }),

/***/ 36:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Font = /** @class */ (function () {
    function Font(pointSize, fontWeight, fontStyle, familyName) {
        if (fontWeight === void 0) { fontWeight = '400'; }
        if (fontStyle === void 0) { fontStyle = 'normal'; }
        this.fontWeight = '400';
        this.fontStyle = 'normal';
        this.pointSize = pointSize;
        this.fontWeight = fontWeight;
        this.fontStyle = fontStyle;
        this.familyName = familyName;
    }
    Font.systemFontOfSize = function (pointSize, weight) {
        if (weight === void 0) { weight = '400'; }
        return new Font(pointSize, weight);
    };
    Font.boldSystemFontOfSize = function (pointSize) {
        return new Font(pointSize, '700');
    };
    Font.italicSystemFontOfSize = function (pointSize) {
        return new Font(pointSize, '400', 'italic');
    };
    return Font;
}());
exports.Font = Font;


/***/ }),

/***/ 37:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(4);
var ScrollView = /** @class */ (function (_super) {
    __extends(ScrollView, _super);
    function ScrollView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDirectionalLockEnabled = true;
        _this.bounces = true;
        _this.isScrollEnabled = true;
        _this.showsHorizontalScrollIndicator = true;
        _this.showsVerticalScrollIndicator = true;
        _this.alwaysBounceVertical = false;
        _this.alwaysBounceHorizontal = false;
        return _this;
    }
    return ScrollView;
}(View_1.View));
exports.ScrollView = ScrollView;


/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var InteractionState;
(function (InteractionState) {
    InteractionState[InteractionState["Began"] = 0] = "Began";
    InteractionState[InteractionState["Changed"] = 1] = "Changed";
    InteractionState[InteractionState["Ended"] = 2] = "Ended";
    InteractionState[InteractionState["Cancelled"] = 3] = "Cancelled";
})(InteractionState = exports.InteractionState || (exports.InteractionState = {}));
var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection[SwipeDirection["ToLeft"] = 0] = "ToLeft";
    SwipeDirection[SwipeDirection["ToRight"] = 1] = "ToRight";
    SwipeDirection[SwipeDirection["ToTop"] = 2] = "ToTop";
    SwipeDirection[SwipeDirection["ToBottom"] = 3] = "ToBottom";
})(SwipeDirection = exports.SwipeDirection || (exports.SwipeDirection = {}));
var View = /** @class */ (function () {
    function View(rect) {
    }
    View.prototype.init = function () { };
    View.prototype.tintColorDidChange = function () { };
    View.prototype.removeFromSuperview = function () { };
    View.prototype.insertSubviewAtIndex = function (subview, atIndex) { };
    View.prototype.exchangeSubviewAtIndex = function (index1, index2) { };
    View.prototype.addSubview = function (subview) { };
    View.prototype.insertSubviewBelow = function (subview, siblingSubview) { };
    View.prototype.insertSubviewAbove = function (subview, siblingSubview) { };
    View.prototype.bringSubviewToFront = function (subview) { };
    View.prototype.sendSubviewToBack = function (subview) { };
    View.prototype.didAddSubview = function (subview) { };
    View.prototype.willRemoveSubview = function (subview) { };
    View.prototype.willMoveToSuperview = function (newSuperview) { };
    View.prototype.didMoveToSuperview = function () { };
    View.prototype.willMoveToWindow = function (newWindow) { };
    View.prototype.didMoveToWindow = function () { };
    View.prototype.isDescendantOfView = function (view) { return false; };
    View.prototype.viewWithTag = function (tag) { return undefined; };
    View.prototype.setNeedsLayout = function () { };
    View.prototype.layoutIfNeeded = function () { };
    View.prototype.layoutSubviews = function () { };
    View.prototype.setNeedsDisplay = function () { };
    View.prototype.addConstraint = function (constraint) { };
    View.prototype.addConstraints = function (constraints) { };
    View.prototype.removeConstraint = function (constraint) { };
    View.prototype.removeAllConstraints = function () { };
    // Mark: View Animation
    View.animationWithDuration = function (duration, animations, completion) { };
    View.animationWithTensionAndFriction = function (tension, friction, animations, completion) { };
    View.animationWithBouncinessAndSpeed = function (bounciness, speed, animations, completion) { };
    View.animationWithDurationDampingVelocity = function (duration, damping, velocity, animations, completion) { }; // iOS Only
    // Mark: View Interactive
    View.InteractionState = InteractionState;
    View.SwipeDirection = SwipeDirection;
    return View;
}());
exports.View = View;


/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(34);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),

/***/ 58:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(59);

/***/ }),

/***/ 59:
/***/ (function(module, exports, __webpack_require__) {

/*
 * Scroller
 * http://github.com/zynga/scroller
 *
 * Copyright 2011, Zynga Inc.
 * Licensed under the MIT License.
 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
 *
 * Based on the work of: Unify Project (unify-project.org)
 * http://unify-project.org
 * Copyright 2011, Deutsche Telekom AG
 * License: MIT + Apache (V2)
 */

var core = __webpack_require__(60);
var Scroller;

(function() {
	var NOOP = function(){};

	/**
	 * A pure logic 'component' for 'virtual' scrolling/zooming.
	 */
	Scroller = function(callback, options) {

		this.__callback = callback;

		this.options = {

			/** Enable scrolling on x-axis */
			scrollingX: true,

			/** Enable scrolling on y-axis */
			scrollingY: true,

			/** Enable animations for deceleration, snap back, zooming and scrolling */
			animating: true,

			/** duration for animations triggered by scrollTo/zoomTo */
			animationDuration: 250,

			/** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */
			bouncing: true,

			/** Enable locking to the main axis if user moves only slightly on one of them at start */
			locking: true,

			/** Enable pagination mode (switching between full page content panes) */
			paging: false,

			/** Enable snapping of content to a configured pixel grid */
			snapping: false,

			/** Enable zooming of content via API, fingers and mouse wheel */
			zooming: false,

			/** Minimum zoom level */
			minZoom: 0.5,

			/** Maximum zoom level */
			maxZoom: 3,

			/** Multiply or decrease scrolling speed **/
			speedMultiplier: 1,

			/** Callback that is fired on the later of touch end or deceleration end,
				provided that another scrolling action has not begun. Used to know
				when to fade out a scrollbar. */
			scrollingComplete: NOOP,

			/** Increase or decrease the amount of friction applied to deceleration **/
			decelerationRate: 0.95,
			
			/** This configures the amount of change applied to deceleration when reaching boundaries  **/
            penetrationDeceleration : 0.03,

            /** This configures the amount of change applied to acceleration when reaching boundaries  **/
            penetrationAcceleration : 0.08

		};

		for (var key in options) {
			this.options[key] = options[key];
		}

	};


	// Easing Equations (c) 2003 Robert Penner, all rights reserved.
	// Open source under the BSD License.

	/**
	 * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
	**/
	var easeOutCubic = function(pos) {
		return (Math.pow((pos - 1), 3) + 1);
	};

	/**
	 * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)
	**/
	var easeInOutCubic = function(pos) {
		if ((pos /= 0.5) < 1) {
			return 0.5 * Math.pow(pos, 3);
		}

		return 0.5 * (Math.pow((pos - 2), 3) + 2);
	};


	var members = {

		/*
		---------------------------------------------------------------------------
			INTERNAL FIELDS :: STATUS
		---------------------------------------------------------------------------
		*/

		/** {Boolean} Whether only a single finger is used in touch handling */
		__isSingleTouch: false,

		/** {Boolean} Whether a touch event sequence is in progress */
		__isTracking: false,

		/** {Boolean} Whether a deceleration animation went to completion. */
		__didDecelerationComplete: false,

		/**
		 * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when
		 * a gesturestart event happens. This has higher priority than dragging.
		 */
		__isGesturing: false,

		/**
		 * {Boolean} Whether the user has moved by such a distance that we have enabled
		 * dragging mode. Hint: It's only enabled after some pixels of movement to
		 * not interrupt with clicks etc.
		 */
		__isDragging: false,

		/**
		 * {Boolean} Not touching and dragging anymore, and smoothly animating the
		 * touch sequence using deceleration.
		 */
		__isDecelerating: false,

		/**
		 * {Boolean} Smoothly animating the currently configured change
		 */
		__isAnimating: false,



		/*
		---------------------------------------------------------------------------
			INTERNAL FIELDS :: DIMENSIONS
		---------------------------------------------------------------------------
		*/

		/** {Integer} Available outer left position (from document perspective) */
		__clientLeft: 0,

		/** {Integer} Available outer top position (from document perspective) */
		__clientTop: 0,

		/** {Integer} Available outer width */
		__clientWidth: 0,

		/** {Integer} Available outer height */
		__clientHeight: 0,

		/** {Integer} Outer width of content */
		__contentWidth: 0,

		/** {Integer} Outer height of content */
		__contentHeight: 0,

		/** {Integer} Snapping width for content */
		__snapWidth: 100,

		/** {Integer} Snapping height for content */
		__snapHeight: 100,

		/** {Integer} Height to assign to refresh area */
		__refreshHeight: null,

		/** {Boolean} Whether the refresh process is enabled when the event is released now */
		__refreshActive: false,

		/** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */
		__refreshActivate: null,

		/** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */
		__refreshDeactivate: null,

		/** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */
		__refreshStart: null,

		/** {Number} Zoom level */
		__zoomLevel: 1,

		/** {Number} Scroll position on x-axis */
		__scrollLeft: 0,

		/** {Number} Scroll position on y-axis */
		__scrollTop: 0,

		/** {Integer} Maximum allowed scroll position on x-axis */
		__maxScrollLeft: 0,

		/** {Integer} Maximum allowed scroll position on y-axis */
		__maxScrollTop: 0,

		/* {Number} Scheduled left position (final position when animating) */
		__scheduledLeft: 0,

		/* {Number} Scheduled top position (final position when animating) */
		__scheduledTop: 0,

		/* {Number} Scheduled zoom level (final scale when animating) */
		__scheduledZoom: 0,



		/*
		---------------------------------------------------------------------------
			INTERNAL FIELDS :: LAST POSITIONS
		---------------------------------------------------------------------------
		*/

		/** {Number} Left position of finger at start */
		__lastTouchLeft: null,

		/** {Number} Top position of finger at start */
		__lastTouchTop: null,

		/** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */
		__lastTouchMove: null,

		/** {Array} List of positions, uses three indexes for each state: left, top, timestamp */
		__positions: null,



		/*
		---------------------------------------------------------------------------
			INTERNAL FIELDS :: DECELERATION SUPPORT
		---------------------------------------------------------------------------
		*/

		/** {Integer} Minimum left scroll position during deceleration */
		__minDecelerationScrollLeft: null,

		/** {Integer} Minimum top scroll position during deceleration */
		__minDecelerationScrollTop: null,

		/** {Integer} Maximum left scroll position during deceleration */
		__maxDecelerationScrollLeft: null,

		/** {Integer} Maximum top scroll position during deceleration */
		__maxDecelerationScrollTop: null,

		/** {Number} Current factor to modify horizontal scroll position with on every step */
		__decelerationVelocityX: null,

		/** {Number} Current factor to modify vertical scroll position with on every step */
		__decelerationVelocityY: null,



		/*
		---------------------------------------------------------------------------
			PUBLIC API
		---------------------------------------------------------------------------
		*/

		/**
		 * Configures the dimensions of the client (outer) and content (inner) elements.
		 * Requires the available space for the outer element and the outer size of the inner element.
		 * All values which are falsy (null or zero etc.) are ignored and the old value is kept.
		 *
		 * @param clientWidth {Integer ? null} Inner width of outer element
		 * @param clientHeight {Integer ? null} Inner height of outer element
		 * @param contentWidth {Integer ? null} Outer width of inner element
		 * @param contentHeight {Integer ? null} Outer height of inner element
		 */
		setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {

			var self = this;

			// Only update values which are defined
			if (clientWidth === +clientWidth) {
				self.__clientWidth = clientWidth;
			}

			if (clientHeight === +clientHeight) {
				self.__clientHeight = clientHeight;
			}

			if (contentWidth === +contentWidth) {
				self.__contentWidth = contentWidth;
			}

			if (contentHeight === +contentHeight) {
				self.__contentHeight = contentHeight;
			}

			// Refresh maximums
			self.__computeScrollMax();

			// Refresh scroll position
			self.scrollTo(self.__scrollLeft, self.__scrollTop, true);

		},


		/**
		 * Sets the client coordinates in relation to the document.
		 *
		 * @param left {Integer ? 0} Left position of outer element
		 * @param top {Integer ? 0} Top position of outer element
		 */
		setPosition: function(left, top) {

			var self = this;

			self.__clientLeft = left || 0;
			self.__clientTop = top || 0;

		},


		/**
		 * Configures the snapping (when snapping is active)
		 *
		 * @param width {Integer} Snapping width
		 * @param height {Integer} Snapping height
		 */
		setSnapSize: function(width, height) {

			var self = this;

			self.__snapWidth = width;
			self.__snapHeight = height;

		},


		/**
		 * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever
		 * the user event is released during visibility of this zone. This was introduced by some apps on iOS like
		 * the official Twitter client.
		 *
		 * @param height {Integer} Height of pull-to-refresh zone on top of rendered list
		 * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.
		 * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.
		 * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.
		 */
		activatePullToRefresh: function(height, activateCallback, deactivateCallback, startCallback) {

			var self = this;

			self.__refreshHeight = height;
			self.__refreshActivate = activateCallback;
			self.__refreshDeactivate = deactivateCallback;
			self.__refreshStart = startCallback;

		},


		/**
		 * Starts pull-to-refresh manually.
		 */
		triggerPullToRefresh: function() {
			// Use publish instead of scrollTo to allow scrolling to out of boundary position
			// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled
			this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);

			if (this.__refreshStart) {
				this.__refreshStart();
			}
		},


		/**
		 * Signalizes that pull-to-refresh is finished.
		 */
		finishPullToRefresh: function() {

			var self = this;

			self.__refreshActive = false;
			if (self.__refreshDeactivate) {
				self.__refreshDeactivate();
			}

			self.scrollTo(self.__scrollLeft, self.__scrollTop, true);

		},


		/**
		 * Returns the scroll position and zooming values
		 *
		 * @return {Map} `left` and `top` scroll position and `zoom` level
		 */
		getValues: function() {

			var self = this;

			return {
				left: self.__scrollLeft,
				top: self.__scrollTop,
				zoom: self.__zoomLevel
			};

		},


		/**
		 * Returns the maximum scroll values
		 *
		 * @return {Map} `left` and `top` maximum scroll values
		 */
		getScrollMax: function() {

			var self = this;

			return {
				left: self.__maxScrollLeft,
				top: self.__maxScrollTop
			};

		},


		/**
		 * Zooms to the given level. Supports optional animation. Zooms
		 * the center when no coordinates are given.
		 *
		 * @param level {Number} Level to zoom to
		 * @param animate {Boolean ? false} Whether to use animation
		 * @param originLeft {Number ? null} Zoom in at given left coordinate
		 * @param originTop {Number ? null} Zoom in at given top coordinate
		 * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
		 */
		zoomTo: function(level, animate, originLeft, originTop, callback) {

			var self = this;

			if (!self.options.zooming) {
				throw new Error("Zooming is not enabled!");
			}

			// Add callback if exists
			if(callback) {
				self.__zoomComplete = callback;
			}

			// Stop deceleration
			if (self.__isDecelerating) {
				core.effect.Animate.stop(self.__isDecelerating);
				self.__isDecelerating = false;
			}

			var oldLevel = self.__zoomLevel;

			// Normalize input origin to center of viewport if not defined
			if (originLeft == null) {
				originLeft = self.__clientWidth / 2;
			}

			if (originTop == null) {
				originTop = self.__clientHeight / 2;
			}

			// Limit level according to configuration
			level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);

			// Recompute maximum values while temporary tweaking maximum scroll ranges
			self.__computeScrollMax(level);

			// Recompute left and top coordinates based on new zoom level
			var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
			var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;

			// Limit x-axis
			if (left > self.__maxScrollLeft) {
				left = self.__maxScrollLeft;
			} else if (left < 0) {
				left = 0;
			}

			// Limit y-axis
			if (top > self.__maxScrollTop) {
				top = self.__maxScrollTop;
			} else if (top < 0) {
				top = 0;
			}

			// Push values out
			self.__publish(left, top, level, animate);

		},


		/**
		 * Zooms the content by the given factor.
		 *
		 * @param factor {Number} Zoom by given factor
		 * @param animate {Boolean ? false} Whether to use animation
		 * @param originLeft {Number ? 0} Zoom in at given left coordinate
		 * @param originTop {Number ? 0} Zoom in at given top coordinate
		 * @param callback {Function ? null} A callback that gets fired when the zoom is complete.
		 */
		zoomBy: function(factor, animate, originLeft, originTop, callback) {

			var self = this;

			self.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);

		},


		/**
		 * Scrolls to the given position. Respect limitations and snapping automatically.
		 *
		 * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>
		 * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>
		 * @param animate {Boolean?false} Whether the scrolling should happen using an animation
		 * @param zoom {Number?null} Zoom level to go to
		 */
		scrollTo: function(left, top, animate, zoom) {

			var self = this;

			// Stop deceleration
			if (self.__isDecelerating) {
				core.effect.Animate.stop(self.__isDecelerating);
				self.__isDecelerating = false;
			}

			// Correct coordinates based on new zoom level
			if (zoom != null && zoom !== self.__zoomLevel) {

				if (!self.options.zooming) {
					throw new Error("Zooming is not enabled!");
				}

				left *= zoom;
				top *= zoom;

				// Recompute maximum values while temporary tweaking maximum scroll ranges
				self.__computeScrollMax(zoom);

			} else {

				// Keep zoom when not defined
				zoom = self.__zoomLevel;

			}

			if (!self.options.scrollingX) {

				left = self.__scrollLeft;

			} else {

				if (self.options.paging) {
					left = Math.round(left / self.__clientWidth) * self.__clientWidth;
				} else if (self.options.snapping) {
					left = Math.round(left / self.__snapWidth) * self.__snapWidth;
				}

			}

			if (!self.options.scrollingY) {

				top = self.__scrollTop;

			} else {

				if (self.options.paging) {
					top = Math.round(top / self.__clientHeight) * self.__clientHeight;
				} else if (self.options.snapping) {
					top = Math.round(top / self.__snapHeight) * self.__snapHeight;
				}

			}

			// Limit for allowed ranges
			left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
			top = Math.max(Math.min(self.__maxScrollTop, top), 0);

			// Don't animate when no change detected, still call publish to make sure
			// that rendered position is really in-sync with internal data
			if (left === self.__scrollLeft && top === self.__scrollTop) {
				animate = false;
			}

			// Publish new values
			self.__publish(left, top, zoom, animate);

		},


		/**
		 * Scroll by the given offset
		 *
		 * @param left {Number ? 0} Scroll x-axis by given offset
		 * @param top {Number ? 0} Scroll x-axis by given offset
		 * @param animate {Boolean ? false} Whether to animate the given change
		 */
		scrollBy: function(left, top, animate) {

			var self = this;

			var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
			var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;

			self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);

		},



		/*
		---------------------------------------------------------------------------
			EVENT CALLBACKS
		---------------------------------------------------------------------------
		*/

		/**
		 * Mouse wheel handler for zooming support
		 */
		doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {

			var self = this;
			var change = wheelDelta > 0 ? 0.97 : 1.03;

			return self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);

		},


		/**
		 * Touch start handler for scrolling support
		 */
		doTouchStart: function(touches, timeStamp) {

			// Array-like check is enough here
			if (touches.length == null) {
				throw new Error("Invalid touch list: " + touches);
			}

			if (timeStamp instanceof Date) {
				timeStamp = timeStamp.valueOf();
			}
			if (typeof timeStamp !== "number") {
				throw new Error("Invalid timestamp value: " + timeStamp);
			}

			var self = this;

			// Reset interruptedAnimation flag
			self.__interruptedAnimation = true;

			// Stop deceleration
			if (self.__isDecelerating) {
				core.effect.Animate.stop(self.__isDecelerating, true);
				self.__isDecelerating = false;
				self.__interruptedAnimation = true;
			}

			// Stop animation
			if (self.__isAnimating) {
				core.effect.Animate.stop(self.__isAnimating, true);
				self.__isAnimating = false;
				self.__interruptedAnimation = true;
			}

			// Use center point when dealing with two fingers
			var currentTouchLeft, currentTouchTop;
			var isSingleTouch = touches.length === 1;
			if (isSingleTouch) {
				currentTouchLeft = touches[0].pageX;
				currentTouchTop = touches[0].pageY;
			} else {
				currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
				currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
			}

			// Store initial positions
			self.__initialTouchLeft = currentTouchLeft;
			self.__initialTouchTop = currentTouchTop;

			// Store current zoom level
			self.__zoomLevelStart = self.__zoomLevel;

			// Store initial touch positions
			self.__lastTouchLeft = currentTouchLeft;
			self.__lastTouchTop = currentTouchTop;

			// Store initial move time stamp
			self.__lastTouchMove = timeStamp;

			// Reset initial scale
			self.__lastScale = 1;

			// Reset locking flags
			self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
			self.__enableScrollY = !isSingleTouch && self.options.scrollingY;

			// Reset tracking flag
			self.__isTracking = true;

			// Reset deceleration complete flag
			self.__didDecelerationComplete = false;

			// Dragging starts directly with two fingers, otherwise lazy with an offset
			self.__isDragging = !isSingleTouch;

			// Some features are disabled in multi touch scenarios
			self.__isSingleTouch = isSingleTouch;

			// Clearing data structure
			self.__positions = [];

		},


		/**
		 * Touch move handler for scrolling support
		 */
		doTouchMove: function(touches, timeStamp, scale) {

			// Array-like check is enough here
			if (touches.length == null) {
				throw new Error("Invalid touch list: " + touches);
			}

			if (timeStamp instanceof Date) {
				timeStamp = timeStamp.valueOf();
			}
			if (typeof timeStamp !== "number") {
				throw new Error("Invalid timestamp value: " + timeStamp);
			}

			var self = this;

			// Ignore event when tracking is not enabled (event might be outside of element)
			if (!self.__isTracking) {
				return;
			}


			var currentTouchLeft, currentTouchTop;

			// Compute move based around of center of fingers
			if (touches.length === 2) {
				currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
				currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
			} else {
				currentTouchLeft = touches[0].pageX;
				currentTouchTop = touches[0].pageY;
			}

			var positions = self.__positions;

			// Are we already is dragging mode?
			if (self.__isDragging) {

				// Compute move distance
				var moveX = currentTouchLeft - self.__lastTouchLeft;
				var moveY = currentTouchTop - self.__lastTouchTop;

				// Read previous scroll position and zooming
				var scrollLeft = self.__scrollLeft;
				var scrollTop = self.__scrollTop;
				var level = self.__zoomLevel;

				// Work with scaling
				if (scale != null && self.options.zooming) {

					var oldLevel = level;

					// Recompute level based on previous scale and new scale
					level = level / self.__lastScale * scale;

					// Limit level according to configuration
					level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);

					// Only do further compution when change happened
					if (oldLevel !== level) {

						// Compute relative event position to container
						var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
						var currentTouchTopRel = currentTouchTop - self.__clientTop;

						// Recompute left and top coordinates based on new zoom level
						scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
						scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;

						// Recompute max scroll values
						self.__computeScrollMax(level);

					}
				}

				if (self.__enableScrollX) {

					scrollLeft -= moveX * this.options.speedMultiplier;
					var maxScrollLeft = self.__maxScrollLeft;

					if (scrollLeft > maxScrollLeft || scrollLeft < 0) {

						// Slow down on the edges
						if (self.options.bouncing) {

							scrollLeft += (moveX / 2  * this.options.speedMultiplier);

						} else if (scrollLeft > maxScrollLeft) {

							scrollLeft = maxScrollLeft;

						} else {

							scrollLeft = 0;

						}
					}
				}

				// Compute new vertical scroll position
				if (self.__enableScrollY) {

					scrollTop -= moveY * this.options.speedMultiplier;
					var maxScrollTop = self.__maxScrollTop;

					if (scrollTop > maxScrollTop || scrollTop < 0) {

						// Slow down on the edges
						if (self.options.bouncing) {

							scrollTop += (moveY / 2 * this.options.speedMultiplier);

							// Support pull-to-refresh (only when only y is scrollable)
							if (!self.__enableScrollX && self.__refreshHeight != null) {

								if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {

									self.__refreshActive = true;
									if (self.__refreshActivate) {
										self.__refreshActivate();
									}

								} else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {

									self.__refreshActive = false;
									if (self.__refreshDeactivate) {
										self.__refreshDeactivate();
									}

								}
							}

						} else if (scrollTop > maxScrollTop) {

							scrollTop = maxScrollTop;

						} else {

							scrollTop = 0;

						}
					}
				}

				// Keep list from growing infinitely (holding min 10, max 20 measure points)
				if (positions.length > 60) {
					positions.splice(0, 30);
				}

				// Track scroll movement for decleration
				positions.push(scrollLeft, scrollTop, timeStamp);

				// Sync scroll position
				self.__publish(scrollLeft, scrollTop, level);

			// Otherwise figure out whether we are switching into dragging mode now.
			} else {

				var minimumTrackingForScroll = self.options.locking ? 3 : 0;
				var minimumTrackingForDrag = 5;

				var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
				var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);

				self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
				self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;

				positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);

				self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
				if (self.__isDragging) {
					self.__interruptedAnimation = false;
				}

			}

			// Update last touch positions and time stamp for next event
			self.__lastTouchLeft = currentTouchLeft;
			self.__lastTouchTop = currentTouchTop;
			self.__lastTouchMove = timeStamp;
			self.__lastScale = scale;

		},


		/**
		 * Touch end handler for scrolling support
		 */
		doTouchEnd: function(timeStamp) {

			if (timeStamp instanceof Date) {
				timeStamp = timeStamp.valueOf();
			}
			if (typeof timeStamp !== "number") {
				throw new Error("Invalid timestamp value: " + timeStamp);
			}

			var self = this;

			// Ignore event when tracking is not enabled (no touchstart event on element)
			// This is required as this listener ('touchmove') sits on the document and not on the element itself.
			if (!self.__isTracking) {
				return;
			}

			// Not touching anymore (when two finger hit the screen there are two touch end events)
			self.__isTracking = false;

			// Be sure to reset the dragging flag now. Here we also detect whether
			// the finger has moved fast enough to switch into a deceleration animation.
			if (self.__isDragging) {

				// Reset dragging flag
				self.__isDragging = false;

				// Start deceleration
				// Verify that the last move detected was in some relevant time frame
				if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {

					// Then figure out what the scroll position was about 100ms ago
					var positions = self.__positions;
					var endPos = positions.length - 1;
					var startPos = endPos;

					// Move pointer to position measured 100ms ago
					for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
						startPos = i;
					}

					// If we haven't received consecutive touchmove events within a 100ms
					// timeframe, attempt a best-effort based on the first position. This
					// typically happens when an expensive operation occurs on the main
					// thread during scrolling, such as image decoding.
					if (startPos === endPos && positions.length > 5) {
						startPos = 2;
					}

					// If start and stop position is identical in a 100ms timeframe,
					// we cannot compute any useful deceleration.
					if (startPos !== endPos) {

						// Compute relative movement between these two points
						var timeOffset = positions[endPos] - positions[startPos];
						var movedLeft = self.__scrollLeft - positions[startPos - 2];
						var movedTop = self.__scrollTop - positions[startPos - 1];

						// Based on 50ms compute the movement to apply for each render step
						self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
						self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);

						// How much velocity is required to start the deceleration
						var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;

						// Verify that we have enough velocity to start deceleration
						if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {

							// Deactivate pull-to-refresh when decelerating
							if (!self.__refreshActive) {
								self.__startDeceleration(timeStamp);
							}
						}
					} else {
						self.options.scrollingComplete();
					}
				} else if ((timeStamp - self.__lastTouchMove) > 100) {
					self.options.scrollingComplete();
	 			}
			}

			// If this was a slower move it is per default non decelerated, but this
			// still means that we want snap back to the bounds which is done here.
			// This is placed outside the condition above to improve edge case stability
			// e.g. touchend fired without enabled dragging. This should normally do not
			// have modified the scroll positions or even showed the scrollbars though.
			if (!self.__isDecelerating) {

				if (self.__refreshActive && self.__refreshStart) {

					// Use publish instead of scrollTo to allow scrolling to out of boundary position
					// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled
					self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);

					if (self.__refreshStart) {
						self.__refreshStart();
					}

				} else {

					if (self.__interruptedAnimation || self.__isDragging) {
						self.options.scrollingComplete();
					}
					self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);

					// Directly signalize deactivation (nothing todo on refresh?)
					if (self.__refreshActive) {

						self.__refreshActive = false;
						if (self.__refreshDeactivate) {
							self.__refreshDeactivate();
						}

					}
				}
			}

			// Fully cleanup list
			self.__positions.length = 0;

		},



		/*
		---------------------------------------------------------------------------
			PRIVATE API
		---------------------------------------------------------------------------
		*/

		/**
		 * Applies the scroll position to the content element
		 *
		 * @param left {Number} Left scroll position
		 * @param top {Number} Top scroll position
		 * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates
		 */
		__publish: function(left, top, zoom, animate) {

			var self = this;

			// Remember whether we had an animation, then we try to continue based on the current "drive" of the animation
			var wasAnimating = self.__isAnimating;
			if (wasAnimating) {
				core.effect.Animate.stop(wasAnimating);
				self.__isAnimating = false;
			}

			if (animate && self.options.animating) {

				// Keep scheduled positions for scrollBy/zoomBy functionality
				self.__scheduledLeft = left;
				self.__scheduledTop = top;
				self.__scheduledZoom = zoom;

				var oldLeft = self.__scrollLeft;
				var oldTop = self.__scrollTop;
				var oldZoom = self.__zoomLevel;

				var diffLeft = left - oldLeft;
				var diffTop = top - oldTop;
				var diffZoom = zoom - oldZoom;

				var step = function(percent, now, render) {

					if (render) {

						self.__scrollLeft = oldLeft + (diffLeft * percent);
						self.__scrollTop = oldTop + (diffTop * percent);
						self.__zoomLevel = oldZoom + (diffZoom * percent);

						// Push values out
						if (self.__callback) {
							self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);
						}

					}
				};

				var verify = function(id) {
					return self.__isAnimating === id;
				};

				var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
					if (animationId === self.__isAnimating) {
						self.__isAnimating = false;
					}
					if (self.__didDecelerationComplete || wasFinished) {
						self.options.scrollingComplete();
					}

					if (self.options.zooming) {
						self.__computeScrollMax();
						if(self.__zoomComplete) {
							self.__zoomComplete();
							self.__zoomComplete = null;
						}
					}
				};

				// When continuing based on previous animation we choose an ease-out animation instead of ease-in-out
				self.__isAnimating = core.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);

			} else {

				self.__scheduledLeft = self.__scrollLeft = left;
				self.__scheduledTop = self.__scrollTop = top;
				self.__scheduledZoom = self.__zoomLevel = zoom;

				// Push values out
				if (self.__callback) {
					self.__callback(left, top, zoom);
				}

				// Fix max scroll ranges
				if (self.options.zooming) {
					self.__computeScrollMax();
					if(self.__zoomComplete) {
						self.__zoomComplete();
						self.__zoomComplete = null;
					}
				}
			}
		},


		/**
		 * Recomputes scroll minimum values based on client dimensions and content dimensions.
		 */
		__computeScrollMax: function(zoomLevel) {

			var self = this;

			if (zoomLevel == null) {
				zoomLevel = self.__zoomLevel;
			}

			self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
			self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);

		},



		/*
		---------------------------------------------------------------------------
			ANIMATION (DECELERATION) SUPPORT
		---------------------------------------------------------------------------
		*/

		/**
		 * Called when a touch sequence end and the speed of the finger was high enough
		 * to switch into deceleration mode.
		 */
		__startDeceleration: function(timeStamp) {

			var self = this;

			if (self.options.paging) {

				var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
				var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
				var clientWidth = self.__clientWidth;
				var clientHeight = self.__clientHeight;

				// We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.
				// Each page should have exactly the size of the client area.
				self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
				self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
				self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
				self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;

			} else {

				self.__minDecelerationScrollLeft = 0;
				self.__minDecelerationScrollTop = 0;
				self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
				self.__maxDecelerationScrollTop = self.__maxScrollTop;

			}

			// Wrap class method
			var step = function(percent, now, render) {
				self.__stepThroughDeceleration(render);
			};

			// How much velocity is required to keep the deceleration running
			var minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;

			// Detect whether it's still worth to continue animating steps
			// If we are already slow enough to not being user perceivable anymore, we stop the whole process here.
			var verify = function() {
				var shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;
				if (!shouldContinue) {
					self.__didDecelerationComplete = true;
				}
				return shouldContinue;
			};

			var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
				self.__isDecelerating = false;
				if (self.__didDecelerationComplete) {
					self.options.scrollingComplete();
				}

				// Animate to grid when snapping is active, otherwise just fix out-of-boundary positions
				self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
			};

			// Start animation and switch on flag
			self.__isDecelerating = core.effect.Animate.start(step, verify, completed);

		},


		/**
		 * Called on every step of the animation
		 *
		 * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!
		 */
		__stepThroughDeceleration: function(render) {

			var self = this;


			//
			// COMPUTE NEXT SCROLL POSITION
			//

			// Add deceleration to scroll position
			var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
			var scrollTop = self.__scrollTop + self.__decelerationVelocityY;


			//
			// HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE
			//

			if (!self.options.bouncing) {

				var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
				if (scrollLeftFixed !== scrollLeft) {
					scrollLeft = scrollLeftFixed;
					self.__decelerationVelocityX = 0;
				}

				var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
				if (scrollTopFixed !== scrollTop) {
					scrollTop = scrollTopFixed;
					self.__decelerationVelocityY = 0;
				}

			}


			//
			// UPDATE SCROLL POSITION
			//

			if (render) {

				self.__publish(scrollLeft, scrollTop, self.__zoomLevel);

			} else {

				self.__scrollLeft = scrollLeft;
				self.__scrollTop = scrollTop;

			}


			//
			// SLOW DOWN
			//

			// Slow down velocity on every iteration
			if (!self.options.paging) {

				// This is the factor applied to every iteration of the animation
				// to slow down the process. This should emulate natural behavior where
				// objects slow down when the initiator of the movement is removed
				var frictionFactor = self.options.decelerationRate;

				self.__decelerationVelocityX *= frictionFactor;
				self.__decelerationVelocityY *= frictionFactor;

			}


			//
			// BOUNCING SUPPORT
			//

			if (self.options.bouncing) {

				var scrollOutsideX = 0;
				var scrollOutsideY = 0;

				// This configures the amount of change applied to deceleration/acceleration when reaching boundaries
				var penetrationDeceleration = self.options.penetrationDeceleration; 
				var penetrationAcceleration = self.options.penetrationAcceleration; 

				// Check limits
				if (scrollLeft < self.__minDecelerationScrollLeft) {
					scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
				} else if (scrollLeft > self.__maxDecelerationScrollLeft) {
					scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
				}

				if (scrollTop < self.__minDecelerationScrollTop) {
					scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
				} else if (scrollTop > self.__maxDecelerationScrollTop) {
					scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
				}

				// Slow down until slow enough, then flip back to snap position
				if (scrollOutsideX !== 0) {
					if (scrollOutsideX * self.__decelerationVelocityX <= 0) {
						self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
					} else {
						self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
					}
				}

				if (scrollOutsideY !== 0) {
					if (scrollOutsideY * self.__decelerationVelocityY <= 0) {
						self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
					} else {
						self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
					}
				}
			}
		}
	};

	// Copy over members to prototype
	for (var key in members) {
		Scroller.prototype[key] = members[key];
	}

	module.exports = Scroller;
})();


/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Color = /** @class */ (function () {
    function Color(r, g, b, a) {
        this.r = Math.min(1.0, Math.max(0.0, r));
        this.g = Math.min(1.0, Math.max(0.0, g));
        ;
        this.b = Math.min(1.0, Math.max(0.0, b));
        ;
        this.a = a == undefined ? 1.0 : Math.min(1.0, Math.max(0.0, a));
        ;
    }
    Color.prototype.rgbHexNumber = function () {
        var r = Math.ceil(this.r * 255).toString(16);
        var g = Math.ceil(this.g * 255).toString(16);
        var b = Math.ceil(this.b * 255).toString(16);
        return parseInt("0x" + (r.length < 2 ? "0" + r : r) + (g.length < 2 ? "0" + g : g) + (b.length < 2 ? "0" + b : b));
    };
    Color.prototype.rgbHexString = function () {
        var r = Math.ceil(this.r * 255).toString(16);
        var g = Math.ceil(this.g * 255).toString(16);
        var b = Math.ceil(this.b * 255).toString(16);
        return "#" + (r.length < 2 ? "0" + r : r) + (g.length < 2 ? "0" + g : g) + (b.length < 2 ? "0" + b : b);
    };
    Color.prototype.equals = function (toColor) {
        if (toColor instanceof Color) {
            return this.r === toColor.r && this.g === toColor.g && this.b === toColor.b && this.a === toColor.a;
        }
        return false;
    };
    Color.colorWithWhite = function (white, alpha) {
        return new Color(white, white, white, alpha);
    };
    Color.whiteColor = new Color(1.0, 1.0, 1.0);
    Color.blackColor = new Color(0.0, 0.0, 0.0);
    Color.clearColor = new Color(0.0, 0.0, 0.0, 0.0);
    Color.redColor = new Color(1.0, 0.0, 0.0);
    Color.yellowColor = new Color(1.0, 1.0, 0.0);
    Color.greenColor = new Color(0.0, 1.0, 0.0);
    Color.blueColor = new Color(0.0, 0.0, 1.0);
    return Color;
}());
exports.Color = Color;


/***/ }),

/***/ 60:
/***/ (function(module, exports) {

/*
 * Scroller
 * http://github.com/zynga/scroller
 *
 * Copyright 2011, Zynga Inc.
 * Licensed under the MIT License.
 * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt
 *
 * Based on the work of: Unify Project (unify-project.org)
 * http://unify-project.org
 * Copyright 2011, Deutsche Telekom AG
 * License: MIT + Apache (V2)
 */

/**
 * Generic animation class with support for dropped frames both optional easing and duration.
 *
 * Optional duration is useful when the lifetime is defined by another condition than time
 * e.g. speed of an animating object, etc.
 *
 * Dropped frame logic allows to keep using the same updater logic independent from the actual
 * rendering. This eases a lot of cases where it might be pretty complex to break down a state
 * based on the pure time difference.
 */
(function (global) {
	var time = Date.now || function () {
		return +new Date();
	};
	var desiredFrames = 60;
	var millisecondsPerSecond = 1000;
	var running = {};
	var keepValue = false;
	var counter = 1;

	// Create namespaces
	var core = {
		effect: {}
	};

	core.effect.Animate = {

		/**
		 * A requestAnimationFrame wrapper / polyfill.
		 *
		 * @param callback {Function} The callback to be invoked before the next repaint.
		 * @param root {HTMLElement} The root element for the repaint
		 */
		requestAnimationFrame: (function () {

			// Check for request animation Frame support
			var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
			var isNative = !!requestFrame;

			if (isNative) {
				return function (callback, root) {
					requestFrame(callback, root)
				};
			}

			var TARGET_FPS = 60;
			var requests = {};
			var requestCount = 0;
			var rafHandle = 1;
			var intervalHandle = null;
			var lastActive = +new Date();

			return function (callback, root) {
				var callbackHandle = rafHandle++;

				// Store callback
				requests[callbackHandle] = callback;
				requestCount++;

				// Create timeout at first request
				if (intervalHandle === null) {

					intervalHandle = setInterval(function () {

						var time = +new Date();
						var currentRequests = requests;

						// Reset data structure before executing callbacks
						requests = {};
						requestCount = 0;

						for (var key in currentRequests) {
							if (currentRequests.hasOwnProperty(key)) {
								currentRequests[key](time);
								lastActive = time;
							}
						}

						// Disable the timeout when nothing happens for a certain
						// period of time
						if (time - lastActive > 2500) {
							clearInterval(intervalHandle);
							intervalHandle = null;
						}

					}, 1000 / TARGET_FPS);
				}

				return callbackHandle;
			};

		})(),


		/**
		 * Stops the given animation.
		 *
		 * @param id {Integer} Unique animation ID
		 * @return {Boolean} Whether the animation was stopped (aka, was running before)
		 */
		stop: function (id, argKeepValue) {
			var cleared = running[id] != null;
			if (cleared) {
				running[id] = null;
			}
			keepValue = argKeepValue === true;
			return cleared;
		},


		/**
		 * Whether the given animation is still running.
		 *
		 * @param id {Integer} Unique animation ID
		 * @return {Boolean} Whether the animation is still running
		 */
		isRunning: function (id) {
			return running[id] != null;
		},


		/**
		 * Start the animation.
		 *
		 * @param stepCallback {Function} Pointer to function which is executed on every step.
		 *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`
		 * @param verifyCallback {Function} Executed before every animation step.
		 *   Signature of the method should be `function() { return continueWithAnimation; }`
		 * @param completedCallback {Function}
		 *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`
		 * @param duration {Integer} Milliseconds to run the animation
		 * @param easingMethod {Function} Pointer to easing function
		 *   Signature of the method should be `function(percent) { return modifiedValue; }`
		 * @param root {Element ? document.body} Render root, when available. Used for internal
		 *   usage of requestAnimationFrame.
		 * @return {Integer} Identifier of animation. Can be used to stop it any time.
		 */
		start: function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {

			var start = time();
			var lastFrame = start;
			var percent = 0;
			var dropCounter = 0;
			var id = counter++;

			if (!root) {
				root = document.body;
			}

			// Compacting running db automatically every few new animations
			if (id % 20 === 0) {
				var newRunning = {};
				for (var usedId in running) {
					newRunning[usedId] = true;
				}
				running = newRunning;
			}

			// This is the internal step method which is called every few milliseconds
			var step = function (virtual) {

				// Normalize virtual value
				var render = virtual !== true;

				// Get current time
				var now = time();

				// Verification is executed before next animation step
				if (!running[id] || (verifyCallback && !verifyCallback(id))) {

					running[id] = null;
					if (keepValue === true) {
						keepValue = false;
						return;
					}
					completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
					return;

				}

				// For the current rendering to apply let's update omitted steps in memory.
				// This is important to bring internal state variables up-to-date with progress in time.
				if (render) {

					var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
					for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
						step(true);
						dropCounter++;
					}

				}

				// Compute percent value
				if (duration) {
					percent = (now - start) / duration;
					if (percent > 1) {
						percent = 1;
					}
				}

				// Execute step callback, then...
				var value = easingMethod ? easingMethod(percent) : percent;
				if ((stepCallback(value, now, render) === false || percent === 1) && render) {
					running[id] = null;
					completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
				} else if (render) {
					lastFrame = now;
					core.effect.Animate.requestAnimationFrame(step, root);
				}
			};

			// Mark as running
			running[id] = true;

			// Init first step
			core.effect.Animate.requestAnimationFrame(step, root);

			// Return unique animation ID
			return id;
		}
	};

	module.exports = core;

})(typeof window !== 'undefined' ? window : this);



/***/ }),

/***/ 61:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(4);
var Color_1 = __webpack_require__(6);
var Label_1 = __webpack_require__(14);
var TextFieldViewMode;
(function (TextFieldViewMode) {
    TextFieldViewMode[TextFieldViewMode["Never"] = 0] = "Never";
    TextFieldViewMode[TextFieldViewMode["WhileEditing"] = 1] = "WhileEditing";
    TextFieldViewMode[TextFieldViewMode["UnlessEditing"] = 2] = "UnlessEditing";
    TextFieldViewMode[TextFieldViewMode["Always"] = 3] = "Always";
})(TextFieldViewMode = exports.TextFieldViewMode || (exports.TextFieldViewMode = {}));
var KeyboardType;
(function (KeyboardType) {
    KeyboardType[KeyboardType["Default"] = 0] = "Default";
    KeyboardType[KeyboardType["ASCIICapable"] = 1] = "ASCIICapable";
    KeyboardType[KeyboardType["NumbersAndPunctuation"] = 2] = "NumbersAndPunctuation";
})(KeyboardType = exports.KeyboardType || (exports.KeyboardType = {}));
var ReturnKeyType;
(function (ReturnKeyType) {
    ReturnKeyType[ReturnKeyType["Default"] = 0] = "Default";
    ReturnKeyType[ReturnKeyType["Go"] = 1] = "Go";
    ReturnKeyType[ReturnKeyType["Next"] = 4] = "Next";
    ReturnKeyType[ReturnKeyType["Search"] = 6] = "Search";
    ReturnKeyType[ReturnKeyType["Send"] = 7] = "Send";
    ReturnKeyType[ReturnKeyType["Done"] = 9] = "Done";
})(ReturnKeyType = exports.ReturnKeyType || (exports.ReturnKeyType = {}));
var TextField = /** @class */ (function (_super) {
    __extends(TextField, _super);
    function TextField() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.textColor = new Color_1.Color(0, 0, 0);
        _this.textAlignment = Label_1.TextAlignment.Left;
        _this.placeholderColor = Color_1.Color.colorWithWhite(0.7, 1.0);
        _this.clearsOnBeginEditing = false;
        _this.editing = false;
        _this.clearButtonMode = TextFieldViewMode.Never;
        _this.leftViewMode = TextFieldViewMode.Never;
        _this.rightViewMode = TextFieldViewMode.Never;
        // TextInput
        _this.allowAutocapitalization = true;
        _this.allowAutocorrection = true;
        _this.allowSpellChecking = true;
        _this.keyboardType = KeyboardType.Default;
        _this.returnKeyType = ReturnKeyType.Default;
        _this.enablesReturnKeyAutomatically = false;
        _this.secureTextEntry = false;
        // TextField Delegate
        _this.shouldBeginEditing = undefined;
        _this.didBeginEditing = undefined;
        _this.shouldEndEditing = undefined;
        _this.didEndEditing = undefined;
        _this.shouldChange = undefined;
        _this.shouldClear = undefined;
        _this.shouldReturn = undefined;
        return _this;
    }
    // methods
    TextField.prototype.focus = function () { };
    TextField.prototype.blur = function () { };
    return TextField;
}(View_1.View));
exports.TextField = TextField;


/***/ }),

/***/ 62:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var View_1 = __webpack_require__(9);
var Rect_1 = __webpack_require__(0);
var ImageRenderingMode;
(function (ImageRenderingMode) {
    ImageRenderingMode[ImageRenderingMode["Automatic"] = 0] = "Automatic";
    ImageRenderingMode[ImageRenderingMode["Original"] = 1] = "Original";
    ImageRenderingMode[ImageRenderingMode["Template"] = 2] = "Template";
})(ImageRenderingMode = exports.ImageRenderingMode || (exports.ImageRenderingMode = {}));
var Image = /** @class */ (function () {
    function Image() {
        this.renderingMode = ImageRenderingMode.Original;
    }
    Image.fromURL = function (url, success, failure) {
        XTRImage.xtr_fromURL(url, success, failure);
    };
    Image.fromAssets = function (named, success, failure) {
        this.fromAssetsWithScales(named, [], success, failure);
    };
    Image.fromAssetsWithScales = function (named, scales, success, failure) {
        XTRImage.xtr_fromAssets(named, this.assetsPath, scales, success, failure);
    };
    Image.fromBase64 = function (value, scale, success) {
        XTRImage.xtr_fromBase64(value, scale, success);
    };
    Image.prototype.imageWithImageRenderingMode = function (renderingMode) {
        return XTRImage.xtr_imageWithImageRenderingMode(this, renderingMode);
    };
    Image.assetsPath = "assets/";
    return Image;
}());
exports.Image = Image;
var ContentMode;
(function (ContentMode) {
    ContentMode[ContentMode["ScaleToFill"] = 0] = "ScaleToFill";
    ContentMode[ContentMode["ScaleAspectFit"] = 1] = "ScaleAspectFit";
    ContentMode[ContentMode["ScaleAspectFill"] = 2] = "ScaleAspectFill";
})(ContentMode = exports.ContentMode || (exports.ContentMode = {}));
var ImageView = /** @class */ (function (_super) {
    __extends(ImageView, _super);
    function ImageView(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        var _this = _super.call(this, undefined, undefined, true) || this;
        if (_isChild) {
            return _this;
        }
        if (nativeObject) {
            _this.nativeObject = nativeObject;
            window.XTRObjCreater.store(_this);
        }
        else {
            _this.nativeObject = XTRImageView.createScriptObject(rect || Rect_1.RectZero, _this);
            window.XTRObjCreater.store(_this);
            _this.init();
        }
        return _this;
    }
    Object.defineProperty(ImageView.prototype, "image", {
        get: function () {
            return this.nativeObject.xtr_image();
        },
        set: function (value) {
            this.nativeObject.xtr_setImage(value);
            this.recursiveSetNeedLayout();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageView.prototype, "contentMode", {
        get: function () {
            return this.nativeObject.xtr_contentMode();
        },
        set: function (value) {
            this.nativeObject.xtr_setContentMode(value);
        },
        enumerable: true,
        configurable: true
    });
    return ImageView;
}(View_1.View));
exports.ImageView = ImageView;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRImageView$InnerObject") === 0) {
        return new ImageView(undefined, view);
    }
    return undefined;
});


/***/ }),

/***/ 9:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Rect_1 = __webpack_require__(0);
var AutoLayout = __webpack_require__(35);
var InteractionState;
(function (InteractionState) {
    InteractionState[InteractionState["Began"] = 0] = "Began";
    InteractionState[InteractionState["Changed"] = 1] = "Changed";
    InteractionState[InteractionState["Ended"] = 2] = "Ended";
    InteractionState[InteractionState["Cancelled"] = 3] = "Cancelled";
})(InteractionState = exports.InteractionState || (exports.InteractionState = {}));
var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection[SwipeDirection["ToLeft"] = 0] = "ToLeft";
    SwipeDirection[SwipeDirection["ToRight"] = 1] = "ToRight";
    SwipeDirection[SwipeDirection["ToTop"] = 2] = "ToTop";
    SwipeDirection[SwipeDirection["ToBottom"] = 3] = "ToBottom";
})(SwipeDirection = exports.SwipeDirection || (exports.SwipeDirection = {}));
var View = /** @class */ (function () {
    function View(rect, nativeObject, _isChild) {
        if (_isChild === void 0) { _isChild = false; }
        // Mark: View LayoutConstraint
        this._constraints = [];
        if (_isChild) {
            return;
        }
        if (nativeObject) {
            this.nativeObject = nativeObject;
            window.XTRObjCreater.store(this);
        }
        else {
            this.nativeObject = XTRView.createScriptObject(rect || Rect_1.RectZero, this);
            window.XTRObjCreater.store(this);
            this.init();
        }
    }
    Object.defineProperty(View.prototype, "objectUUID", {
        get: function () {
            return "" + this.nativeObject.objectUUID;
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.init = function () { };
    Object.defineProperty(View.prototype, "frame", {
        // Mark: View Geometry
        get: function () {
            return this.nativeObject.xtr_frame();
        },
        set: function (value) {
            this.nativeObject.xtr_setFrame(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "bounds", {
        get: function () {
            return this.nativeObject.xtr_bounds();
        },
        set: function (value) {
            return;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "center", {
        get: function () {
            return { x: this.frame.x + this.frame.width / 2.0, y: this.frame.y + this.frame.height / 2.0 };
        },
        set: function (value) {
            var newFrame = __assign({}, this.frame);
            newFrame.x = value.x - newFrame.width / 2.0;
            newFrame.y = value.y - newFrame.height / 2.0;
            this.frame = newFrame;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "transform", {
        get: function () {
            return this.nativeObject.xtr_transform();
        },
        set: function (value) {
            this.nativeObject.xtr_setTransform(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "clipsToBounds", {
        // Mark: View Rendering
        get: function () {
            return this.nativeObject.xtr_clipsToBounds();
        },
        set: function (value) {
            this.nativeObject.xtr_setClipsToBounds(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "backgroundColor", {
        get: function () {
            return this.nativeObject.xtr_backgroundColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setBackgroundColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "alpha", {
        get: function () {
            return this.nativeObject.alpha;
        },
        set: function (value) {
            this.nativeObject.alpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "opaque", {
        get: function () {
            return this.nativeObject.xtr_opaque();
        },
        set: function (value) {
            this.nativeObject.xtr_setOpaque(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "hidden", {
        get: function () {
            return this.nativeObject.xtr_hidden();
        },
        set: function (value) {
            this.nativeObject.xtr_setHidden(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "tintColor", {
        get: function () {
            return this.nativeObject.xtr_tintColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setTintColor(value);
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.tintColorDidChange = function () { };
    View.prototype.setNeedsDisplay = function () { };
    Object.defineProperty(View.prototype, "cornerRadius", {
        // Mark: View Layer-Back Rendering
        get: function () {
            return this.nativeObject.xtr_cornerRadius();
        },
        set: function (value) {
            this.nativeObject.xtr_setCornerRadius(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "borderWidth", {
        get: function () {
            return this.nativeObject.xtr_borderWidth();
        },
        set: function (value) {
            this.nativeObject.xtr_setBorderWidth(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "borderColor", {
        get: function () {
            return this.nativeObject.xtr_borderColor();
        },
        set: function (value) {
            this.nativeObject.xtr_setBorderColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "tag", {
        // Mark: View Hierarchy
        get: function () {
            return this.nativeObject.xtr_tag;
        },
        set: function (value) {
            this.nativeObject.xtr_tag = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "superview", {
        get: function () {
            return this.nativeObject.xtr_superview();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "subviews", {
        get: function () {
            return this.nativeObject.xtr_subviews();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "window", {
        get: function () {
            return this.nativeObject.xtr_window();
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.removeFromSuperview = function () {
        this.nativeObject.xtr_removeFromSuperview();
    };
    View.prototype.insertSubviewAtIndex = function (subview, atIndex) {
        this.nativeObject.xtr_insertSubviewAtIndex(subview, atIndex);
    };
    View.prototype.exchangeSubviewAtIndex = function (index1, index2) {
        this.nativeObject.exchangeSubviewAtIndex(index1, index2);
    };
    View.prototype.addSubview = function (subview) {
        this.nativeObject.xtr_addSubview(subview);
    };
    View.prototype.insertSubviewBelow = function (subview, siblingSubview) {
        this.nativeObject.xtr_insertSubviewBelow(subview, siblingSubview);
    };
    View.prototype.insertSubviewAbove = function (subview, siblingSubview) {
        this.nativeObject.xtr_insertSubviewAbove(subview, siblingSubview);
    };
    View.prototype.bringSubviewToFront = function (subview) {
        this.nativeObject.xtr_bringSubviewToFront(subview);
    };
    View.prototype.sendSubviewToBack = function (subview) {
        this.nativeObject.xtr_sendSubviewToBack(subview);
    };
    View.prototype.didAddSubview = function (subview) { };
    View.prototype.willRemoveSubview = function (subview) { };
    View.prototype.willMoveToSuperview = function (newSuperview) { };
    View.prototype.didMoveToSuperview = function () { };
    View.prototype.willMoveToWindow = function (newWindow) { };
    View.prototype.didMoveToWindow = function () { };
    View.prototype.isDescendantOfView = function (view) { return this.nativeObject.xtr_isDescendantOfView(view); };
    View.prototype.viewWithTag = function (tag) { return this.nativeObject.xtr_viewWithTag(tag); };
    View.prototype.setNeedsLayout = function () { this.nativeObject.xtr_setNeedsLayout(); };
    View.prototype.recursiveSetNeedLayout = function () {
        var current = this;
        while (current) {
            current.setNeedsLayout();
            current = current.superview;
        }
    };
    View.prototype.layoutIfNeeded = function () { this.nativeObject.xtr_layoutIfNeeded(); };
    View.prototype.layoutSubviews = function () {
        if (this._constraints.length > 0) {
            var viewMapping_1 = {};
            this._constraints.forEach(function (item) {
                if (item.firstItem !== undefined) {
                    viewMapping_1[item.firstItem.objectUUID] = item.firstItem;
                }
                if (item.secondItem !== undefined) {
                    viewMapping_1[item.secondItem.objectUUID] = item.secondItem;
                }
            });
            var view = new AutoLayout.View({
                constraints: this._constraints.map(function (item) { return item.toALObject(); }),
                width: this.bounds.width,
                height: this.bounds.height,
            });
            for (var layoutID in view.subViews) {
                var value = view.subViews[layoutID];
                if (viewMapping_1[layoutID] !== undefined) {
                    var intrinsticSize = viewMapping_1[layoutID].intrinsicContentSize(value.width != 0 ? value.width : undefined);
                    if (intrinsticSize !== undefined && intrinsticSize !== null) {
                        value.intrinsicWidth = intrinsticSize.width;
                        value.intrinsicHeight = intrinsticSize.height;
                    }
                }
            }
            for (var layoutID in view.subViews) {
                var value = view.subViews[layoutID];
                if (viewMapping_1[layoutID] !== undefined) {
                    if (viewMapping_1[layoutID] == this) {
                        continue;
                    }
                    viewMapping_1[layoutID].frame = {
                        x: value.left,
                        y: value.top,
                        width: value.width,
                        height: value.height,
                    };
                }
            }
        }
    };
    Object.defineProperty(View.prototype, "constraints", {
        get: function () {
            return this._constraints.slice();
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.intrinsicContentSize = function (width) {
        return this.nativeObject.xtr_intrinsicContentSize(width || Infinity);
    };
    View.prototype.addConstraint = function (constraint) {
        this._constraints.push(constraint);
    };
    View.prototype.addConstraints = function (constraints) {
        var _this = this;
        constraints.forEach(function (constraint) { return _this._constraints.push(constraint); });
    };
    View.prototype.removeConstraint = function (constraint) {
        var idx = this._constraints.indexOf(constraint);
        if (idx >= 0) {
            this._constraints.splice(idx, 1);
        }
    };
    View.prototype.removeAllConstraints = function () {
        this._constraints = [];
    };
    Object.defineProperty(View.prototype, "userInteractionEnabled", {
        get: function () {
            return this.nativeObject.xtr_userInteractionEnabled();
        },
        set: function (value) {
            this.nativeObject.xtr_setUserInteractionEnabled(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "longPressDuration", {
        get: function () {
            return this.nativeObject.xtr_longPressDuration();
        },
        set: function (value) {
            this.nativeObject.xtr_setLongPressDuration(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "onTap", {
        set: function (value) {
            this.nativeObject.xtr_setTap(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "onDoubleTap", {
        set: function (value) {
            this.nativeObject.xtr_setDoubleTap(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "onLongPress", {
        set: function (value) {
            this.nativeObject.xtr_setLongPress(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "onPan", {
        set: function (value) {
            this.nativeObject.xtr_setPan(value);
        },
        enumerable: true,
        configurable: true
    });
    // Mark: View Animation
    View.animationWithDuration = function (duration, animations, completion) {
        XTRView.animationWithDuration(duration, animations, completion);
    };
    View.animationWithTensionAndFriction = function (tension, friction, animations, completion) {
        XTRView.animationWithTensionAndFriction(tension, friction, animations, completion);
    };
    View.animationWithBouncinessAndSpeed = function (bounciness, speed, animations, completion) {
        XTRView.animationWithBouncinessAndSpeed(bounciness, speed, animations, completion);
    };
    View.animationWithDurationDampingVelocity = function (duration, damping, velocity, animations, completion) { }; // iOS Only
    // Mark: View Interactive
    View.InteractionState = InteractionState;
    View.SwipeDirection = SwipeDirection;
    return View;
}());
exports.View = View;
if (window.XTRObjClasses === undefined) {
    window.XTRObjClasses = [];
}
window.XTRObjClasses.push(function (view) {
    if (view.toString().indexOf("com.opensource.xtruntime.XTRView$InnerObject") === 0) {
        return new View(undefined, view);
    }
    return undefined;
});


/***/ })

/******/ });
//# sourceMappingURL=sample.android.min.js.map